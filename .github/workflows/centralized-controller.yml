# =============================================================================
# CENTRALIZED TERRAFORM CONTROLLER - OPTIMIZED
# =============================================================================
name: Centralized Controller

on:
  repository_dispatch:
    types: [terraform_pr, terraform_apply]

permissions:
  id-token: write
  contents: read
  actions: read

env:
  TERRAFORM_VERSION: '1.11.0'
  OPA_VERSION: '0.59.0'
  AWS_REGION: 'us-east-1'

jobs:
  terraform-controller:
    name: üéØ Terraform Controller
    runs-on: ubuntu-latest
    if: github.event.action == 'terraform_pr' || github.event.client_payload.action != 'apply'
    steps:
      - name: üìã Setup & Event Details
        id: setup
        run: |
          echo "üîî Source: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}"
          echo "üìã PR: #${{ github.event.client_payload.pr_number }} (${{ github.event.client_payload.pr_head_ref }})"

      - name: Generate GitHub App Token
        id: app-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GT_APP_ID }}
          private_key: ${{ secrets.GT_APP_PRIVATE_KEY }}

      - name: Checkout Repos
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/centerlized-pipline-
          path: controller
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout Source Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}
          ref: ${{ github.event.client_payload.pr_head_ref }}
          path: source-repo
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout OPA Policies
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/OPA-Poclies
          path: opa-policies
          token: ${{ steps.app-token.outputs.token }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-controller

      - name: üîß Setup Tools
        run: |
          # Configure Git for Terraform module access
          git config --global url."https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/".insteadOf "https://github.com/"
          
          # Setup Terraform
          curl -fsSL https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip -o terraform.zip
          unzip terraform.zip && sudo mv terraform /usr/local/bin/
          
          # Setup OPA (with fallback)
          curl -L -o opa https://openpolicyagent.org/downloads/v${{ env.OPA_VERSION }}/opa_linux_amd64_static || \
          curl -L -o opa https://github.com/open-policy-agent/opa/releases/download/v${{ env.OPA_VERSION }}/opa_linux_amd64_static
          chmod +x opa && sudo mv opa /usr/local/bin/
          
          # Setup yq
          sudo snap install yq
          
          # Pre-pull Docker image
          docker pull bridgecrew/checkov:latest

      - name: üîç Discover & Validate
        id: discover
        working-directory: source-repo
        run: |
          echo "üîç Discovering deployments..."
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --output-summary deployments.json --debug --working-dir .
          
          if [ -f deployments.json ]; then
            deployments=$(jq -r '.total_deployments // 0' deployments.json)
            echo "üì¶ Found $deployments deployments"
            echo "has_deployments=$([[ $deployments -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
            echo "deployment_count=$deployments" >> $GITHUB_OUTPUT
          else
            echo "has_deployments=false" >> $GITHUB_OUTPUT
            echo "deployment_count=0" >> $GITHUB_OUTPUT
          fi

      - name: üõ°Ô∏è Security Scan
        if: steps.discover.outputs.has_deployments == 'true'
        id: security
        working-directory: source-repo
        run: |
          echo "üõ°Ô∏è Running Checkov security scan..."
          
          # Get deployment files
          DEPLOYMENT_FILES=$(jq -r '.deployments[].tfvars_file' deployments.json | tr '\n' ' ')
          echo "üìÑ Scanning: $DEPLOYMENT_FILES"
          
          # Load security config
          CRITICAL_CHECKS=$(yq eval '.security_checks.critical[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
          HIGH_CHECKS=$(yq eval '.security_checks.high[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
          MEDIUM_CHECKS=$(yq eval '.security_checks.medium[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
          ALL_CHECKS="${CRITICAL_CHECKS},${HIGH_CHECKS},${MEDIUM_CHECKS}"
          
          # Run Checkov on directory instead of specific files
          mkdir -p checkov-results
          docker run --rm -v $PWD:/tf bridgecrew/checkov:latest \
            --framework terraform --check $ALL_CHECKS \
            --output json --output-file-path /tf/checkov-results/ \
            --quiet --soft-fail --compact \
            --directory /tf/Accounts || true
          
          # Process results
          if [ -f "checkov-results/results_json.json" ]; then
            critical=$(jq --arg checks "$CRITICAL_CHECKS" '[.results.failed_checks[]? | select(.check_id | IN($checks | split(",")))] | length' checkov-results/results_json.json 2>/dev/null || echo "0")
            high=$(jq --arg checks "$HIGH_CHECKS" '[.results.failed_checks[]? | select(.check_id | IN($checks | split(",")))] | length' checkov-results/results_json.json 2>/dev/null || echo "0")
            medium=$(jq --arg checks "$MEDIUM_CHECKS" '[.results.failed_checks[]? | select(.check_id | IN($checks | split(",")))] | length' checkov-results/results_json.json 2>/dev/null || echo "0")
            total=$((critical + high + medium))
            
            echo "üî¥ Critical: $critical, üü† High: $high, üü° Medium: $medium"
            echo "critical_issues=$critical" >> $GITHUB_OUTPUT
            echo "high_issues=$high" >> $GITHUB_OUTPUT
            echo "medium_issues=$medium" >> $GITHUB_OUTPUT
            echo "total_issues=$total" >> $GITHUB_OUTPUT
            
            # Determine status
            if [ "$critical" -gt 0 ]; then
              echo "scan_status=failed" >> $GITHUB_OUTPUT
              echo "scan_message=üî¥ Critical security issues found ($critical)" >> $GITHUB_OUTPUT
            elif [ "$high" -gt 2 ]; then
              echo "scan_status=failed" >> $GITHUB_OUTPUT
              echo "scan_message=‚ö†Ô∏è Too many high severity issues ($high)" >> $GITHUB_OUTPUT
            else
              echo "scan_status=passed" >> $GITHUB_OUTPUT
              echo "scan_message=‚úÖ Security scan passed" >> $GITHUB_OUTPUT
            fi
          else
            echo "scan_status=passed" >> $GITHUB_OUTPUT
            echo "scan_message=‚ÑπÔ∏è No security issues detected" >> $GITHUB_OUTPUT
          fi

      - name: üìã Terraform Plan
        if: steps.discover.outputs.has_deployments == 'true'
        id: plan
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "üìã Running terraform plan..."
          
          set +e
          python3 ../controller/scripts/terraform-deployment-orchestrator.py plan \
            --deployments-json deployments.json --output-summary plan-results.json --debug --working-dir .
          plan_exit_code=$?
          set -e
          
          if [ -f plan-results.json ]; then
            total=$(jq -r '.total_deployments // 0' plan-results.json)
            successful=$(jq -r '.successful_plans // 0' plan-results.json)
            failed=$(jq -r '.failed_plans // 0' plan-results.json)
            has_changes=$(jq -r '.has_changes // false' plan-results.json)
            
            echo "üìä Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_plans=$successful" >> $GITHUB_OUTPUT
            echo "failed_plans=$failed" >> $GITHUB_OUTPUT
            echo "has_changes=$has_changes" >> $GITHUB_OUTPUT
            
            # Prepare OPA validation
            if [ -d "terraform-json" ] && [ "$successful" -gt 0 ]; then
              mkdir -p canonical-plan
              FIRST_JSON=$(ls terraform-json/*.json 2>/dev/null | head -n1)
              if [ -n "$FIRST_JSON" ]; then
                cp "$FIRST_JSON" canonical-plan/plan.json
                echo "opa_plan_ready=true" >> $GITHUB_OUTPUT
              else
                echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
            fi
            
            [[ "$successful" -gt 0 ]] || exit 1
          else
            echo "‚ùå No plan results found" && exit 1
          fi

      - name: üõ°Ô∏è Policy Validation (Project-based + Default)
        if: steps.plan.outputs.opa_plan_ready == 'true'
        id: opa
        working-directory: source-repo
        run: |
          echo "üõ°Ô∏è Running OPA validation with project-based policies..."
          
          # Check for project-specific policies first
          PROJECT_NAME="${{ github.event.client_payload.source_repo }}"
          echo "üîç Looking for project-specific policies for: $PROJECT_NAME"
          
          PROJECT_POLICY_DIR="../opa-policies/projects/$PROJECT_NAME"
          DEFAULT_POLICY_DIR="../opa-policies/terraform"
          
          # Determine which policies to use
          if [ -d "$PROJECT_POLICY_DIR" ] && [ -f "$PROJECT_POLICY_DIR/main.rego" ]; then
            echo "‚úÖ Found project-specific policies: $PROJECT_POLICY_DIR"
            POLICY_DIR="$PROJECT_POLICY_DIR"
            POLICY_TYPE="project-specific"
            echo "project_policy_found=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No project-specific policies found, using default policies"
            POLICY_DIR="$DEFAULT_POLICY_DIR"
            POLICY_TYPE="default"
            echo "project_policy_found=false" >> $GITHUB_OUTPUT
          fi
          
          echo "üìã Using policy type: $POLICY_TYPE"
          echo "policy_type=$POLICY_TYPE" >> $GITHUB_OUTPUT
          
          # Run validation with selected policies
          opa eval -d "$POLICY_DIR" -i canonical-plan/plan.json \
            "data.terraform.main.validate_plan" --format json > opa-validation.json
          
          # Extract results
          violations=$(jq -r '.result[0].expressions[0].value.total_violations // 0' opa-validation.json)
          critical=$(jq -r '.result[0].expressions[0].value.critical_violations // 0' opa-validation.json)
          high=$(jq -r '.result[0].expressions[0].value.high_violations // 0' opa-validation.json)
          
          echo "üîç Policy Results:"
          echo "   Policy Type: $POLICY_TYPE"
          echo "   Total Violations: $violations"
          echo "   Critical: $critical"
          echo "   High: $high"
          
          echo "total_violations=$violations" >> $GITHUB_OUTPUT
          echo "critical_violations=$critical" >> $GITHUB_OUTPUT
          echo "high_violations=$high" >> $GITHUB_OUTPUT
          
          # Save violation details for PR comment
          if [ "$violations" -gt 0 ]; then
            jq -r '.result[0].expressions[0].value.violation_details[]?' opa-validation.json > opa-result.txt 2>/dev/null || echo "No detailed violation info available" > opa-result.txt
          fi
          
          # Determine validation status - all violations require manual review
          if [ "$violations" -eq 0 ]; then
            echo "validation_status=passed" >> $GITHUB_OUTPUT
            echo "requires_review=false" >> $GITHUB_OUTPUT
            echo "‚úÖ All policies passed!"
          else
            # All policy violations require manual review before merge
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            echo "requires_review=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Policy violations found - manual review required before merge"
          fi

      - name: üí¨ Enhanced PR Comments
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const prAuthor = '${{ github.event.client_payload.pr_author }}';
            const prNumber = '${{ github.event.client_payload.pr_number }}';
            
            let comment = `## üöÄ Centralized Terraform Controller Results\n\n`;
            comment += `**üë§ PR Author**: @${prAuthor}\n`;
            comment += `**Source**: \`${{ github.event.client_payload.source_repo }}\`\n`;
            comment += `**PR**: [#${prNumber}](${{ github.event.client_payload.pr_url }})\n\n`;
            
            // Security Results
            const scanStatus = '${{ steps.security.outputs.scan_status }}';
            const criticalIssues = '${{ steps.security.outputs.critical_issues }}' || '0';
            const highIssues = '${{ steps.security.outputs.high_issues }}' || '0';
            const totalIssues = '${{ steps.security.outputs.total_issues }}' || '0';
            
            comment += `### üõ°Ô∏è Security Scan\n`;
            comment += `**Status**: ${{ steps.security.outputs.scan_message }}\n`;
            if (totalIssues !== '0') {
              comment += `üî¥ Critical: ${criticalIssues} | üü† High: ${highIssues} | üìä Total: ${totalIssues}\n`;
              if (parseInt(criticalIssues) > 0) {
                comment += `> üö® **URGENT @${prAuthor}**: Critical security issues detected!\n`;
              }
            }
            comment += `\n`;
            
            // Plan Results
            const total = '${{ steps.plan.outputs.total_deployments }}' || '0';
            const successful = '${{ steps.plan.outputs.successful_plans }}' || '0';
            const failed = '${{ steps.plan.outputs.failed_plans }}' || '0';
            
            comment += `### üìã Terraform Plan\n`;
            comment += `‚úÖ Successful: ${successful}/${total} | ‚ùå Failed: ${failed}\n\n`;
            
            // Enhanced OPA Results
            const validation = '${{ steps.opa.outputs.validation_status }}';
            const violations = '${{ steps.opa.outputs.total_violations }}' || '0';
            const policyType = '${{ steps.opa.outputs.policy_type }}' || 'unknown';
            const projectPolicyFound = '${{ steps.opa.outputs.project_policy_found }}';
            const requiresReview = '${{ steps.opa.outputs.requires_review }}';
            
            comment += `### üõ°Ô∏è Policy Validation (${policyType})\n`;
            if (validation === 'passed') {
              comment += `‚úÖ **All policies passed!**\n`;
              comment += `\n### ‚úÖ Ready for Manual Merge\n`;
              comment += `**This PR can be safely merged manually** after team review.\n\n`;
              comment += `**Next Steps:**\n`;
              comment += `1. Team review and approval\n`;
              comment += `2. Manual merge to trigger deployment\n`;
              comment += `3. Monitor apply process\n\n`;
            } else {
              comment += `‚ùå **${violations} violations** detected using **${policyType}** policies\n`;
              
              if (projectPolicyFound === 'false') {
                comment += `> üí° No project-specific policies found, using default validation rules\n`;
              }
              
              comment += `\n### ÔøΩ Manual Review Required\n`;
              comment += `**Policy violations must be resolved before merge.**\n\n`;
              comment += `**Next Steps:**\n`;
              comment += `1. ‚úèÔ∏è Fix all policy violations listed above\n`;
              comment += `2. üîÑ Push changes to update this PR\n`;
              comment += `3. ‚è≥ Wait for re-validation\n`;
              comment += `4. ‚úÖ Manual merge after all checks pass\n\n`;
              comment += `> ‚ö†Ô∏è **Important:** Do not merge until all violations are resolved!\n`;
            }
                comment += `**Why?** Default policies represent mandatory security requirements.\n`;
                comment += `**Fix Required:** Address all violations and reopen a new PR.\n`;
              }
            }
            comment += `\n`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: prNumber,
              body: comment
            });

      - name: üö´ Policy Violation Summary
        if: steps.opa.outputs.validation_status == 'failed'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const violations = '${{ steps.opa.outputs.total_violations }}';
            const policyType = '${{ steps.opa.outputs.policy_type }}';
            
            console.log(`‚ö†Ô∏è Policy validation failed: ${violations} violations found using ${policyType} policies`);
            console.log('üìã Manual review required before merge');

      - name: üè∑Ô∏è Label PR Based on Validation Results
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const prNumber = '${{ github.event.client_payload.pr_number }}';
            const validation = '${{ steps.opa.outputs.validation_status }}';
            const violations = '${{ steps.opa.outputs.total_violations }}' || '0';
            const scanStatus = '${{ steps.security.outputs.scan_status }}';
            const criticalIssues = '${{ steps.security.outputs.critical_issues }}' || '0';
            
            console.log('üè∑Ô∏è Adding appropriate labels based on validation results');
            
            // Remove any existing status labels first
            try {
              const existingLabels = await github.rest.issues.listLabelsOnIssue({
                owner: '${{ github.event.client_payload.source_owner }}',
                repo: '${{ github.event.client_payload.source_repo }}',
                issue_number: prNumber
              });
              
              const statusLabels = existingLabels.data.filter(label => 
                label.name.includes('validation') || 
                label.name.includes('security') ||
                label.name.includes('ready') ||
                label.name.includes('blocked')
              );
              
              for (const label of statusLabels) {
                await github.rest.issues.removeLabel({
                  owner: '${{ github.event.client_payload.source_owner }}',
                  repo: '${{ github.event.client_payload.source_repo }}',
                  issue_number: prNumber,
                  name: label.name
                });
              }
            } catch (error) {
              console.log('Note: Could not remove existing labels:', error.message);
            }
            
            // Add appropriate new labels
            const labelsToAdd = [];
            
            if (validation === 'passed' && scanStatus !== 'failed') {
              labelsToAdd.push('validation-passed', 'ready-for-manual-merge');
            } else {
              labelsToAdd.push('validation-failed', 'blocked-needs-fixes');
              
              if (parseInt(violations) > 0) {
                labelsToAdd.push('policy-violations');
              }
              
              if (parseInt(criticalIssues) > 0) {
                labelsToAdd.push('security-critical');
              }
            }
            
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: '${{ github.event.client_payload.source_owner }}',
                repo: '${{ github.event.client_payload.source_repo }}',
                issue_number: prNumber,
                labels: labelsToAdd
              });
              
              console.log(`‚úÖ Added labels: ${labelsToAdd.join(', ')}`);
            }

      - name: ÔøΩ Critical Alert
        if: steps.security.outputs.scan_status == 'failed' && steps.security.outputs.critical_issues > 0
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const prAuthor = '${{ github.event.client_payload.pr_author }}';
            const criticalCount = '${{ steps.security.outputs.critical_issues }}';
            const prNumber = '${{ github.event.client_payload.pr_number }}';
            
            const alertComment = `üö® **URGENT SECURITY ALERT** üö®\n\n` +
              `@${prAuthor} - **${criticalCount} Critical Security Issues** detected!\n\n` +
              `‚õî **Action Required**: Please fix these issues before proceeding.\n\n` +
              `ÔøΩ *Automated Security Alert*`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: prNumber,
              body: alertComment
            });

      - name: ÔøΩ Final Validation Summary
        if: always() && steps.discover.outputs.has_deployments == 'true'
        run: |
          echo "======================================"
          echo "üéØ CENTRALIZED CONTROLLER SUMMARY"
          echo "======================================"
          echo "üìÅ Source: ${{ github.event.client_payload.source_repo }}"
          echo "üî¢ PR: #${{ github.event.client_payload.pr_number }}"
          echo "üë§ Author: ${{ github.event.client_payload.pr_author }}"
          echo ""
          echo "üõ°Ô∏è VALIDATION RESULTS:"
          echo "   Security Scan: ${{ steps.security.outputs.scan_status || 'not-run' }}"
          echo "   Policy Check: ${{ steps.opa.outputs.validation_status || 'not-run' }}"
          echo "   Violations: ${{ steps.opa.outputs.total_violations || '0' }}"
          echo "   Critical Issues: ${{ steps.security.outputs.critical_issues || '0' }}"
          echo ""
          echo "üîß NEXT STEPS:"
          if [[ "${{ steps.opa.outputs.validation_status }}" == "passed" && "${{ steps.security.outputs.scan_status }}" != "failed" ]]; then
            echo "   ‚úÖ Ready for MANUAL MERGE"
            echo "   ‚ö†Ô∏è  No auto-merge - manual review required"
            echo "   üöÄ Manual merge will trigger apply process"
          else
            echo "   ‚ùå BLOCKED - Fix violations before merge"
            echo "   üìù Check PR comments for details"
            echo "   üîÑ Push fixes to re-trigger validation"
          fi
          echo "======================================"

  # =============================================================================
  # TERRAFORM APPLY JOB (Runs after manual merge)
  # =============================================================================
  terraform-apply:
    name: üöÄ Terraform Apply
    runs-on: ubuntu-latest
    if: github.event.action == 'terraform_apply' || github.event.client_payload.action == 'apply'
    steps:
      - name: üìã Apply Event Details
        run: |
          echo "üöÄ Terraform Apply Triggered"
          echo "Source: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}"
          echo "Branch: ${{ github.event.client_payload.branch || 'main' }}"
          echo "Commit: ${{ github.event.client_payload.commit_sha }}"

      - name: Generate GitHub App Token
        id: app-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GT_APP_ID }}
          private_key: ${{ secrets.GT_APP_PRIVATE_KEY }}

      - name: Checkout Repos
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/centerlized-pipline-
          path: controller
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout Source Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}
          ref: ${{ github.event.client_payload.branch || 'main' }}
          path: source-repo
          token: ${{ steps.app-token.outputs.token }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-apply

      - name: üîß Setup Terraform
        run: |
          # Configure Git for Terraform module access
          git config --global url."https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/".insteadOf "https://github.com/"
          
          curl -fsSL https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip -o terraform.zip
          unzip terraform.zip && sudo mv terraform /usr/local/bin/

      - name: Checkout OPA Policies
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/OPA-Poclies
          path: opa-policies
          token: ${{ steps.app-token.outputs.token }}

      - name: üõ†Ô∏è Setup OPA for Apply Validation
        run: |
          echo "üõ†Ô∏è Installing OPA for apply-time validation..."
          
          # Setup OPA (with fallback)
          curl -L -o opa https://openpolicyagent.org/downloads/v${{ env.OPA_VERSION }}/opa_linux_amd64_static || \
          curl -L -o opa https://github.com/open-policy-agent/opa/releases/download/v${{ env.OPA_VERSION }}/opa_linux_amd64_static
          chmod +x opa && sudo mv opa /usr/local/bin/

      - name: üîç Discover Deployments
        id: discover
        working-directory: source-repo
        run: |
          echo "üîç Discovering deployments for apply..."
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --output-summary deployments.json --debug --working-dir .
          
          if [ -f deployments.json ]; then
            deployments=$(jq -r '.total_deployments // 0' deployments.json)
            echo "üì¶ Found $deployments deployments to apply"
            echo "has_deployments=$([[ $deployments -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          else
            echo "has_deployments=false" >> $GITHUB_OUTPUT
          fi

      - name: üõ°Ô∏è Pre-Apply Policy Validation
        if: steps.discover.outputs.has_deployments == 'true'
        id: pre_apply_validation
        working-directory: source-repo
        run: |
          echo "üõ°Ô∏è Running pre-apply policy validation..."
          
          # Generate new plan for current state validation
          set +e
          python3 ../controller/scripts/terraform-deployment-orchestrator.py plan \
            --deployments-json deployments.json --output-summary pre-apply-plan-results.json --debug --working-dir .
          plan_exit_code=$?
          set -e
          
          if [ $plan_exit_code -eq 0 ] && [ -f canonical-plan/plan.json ]; then
            echo "‚úÖ Plan generated successfully for pre-apply validation"
            
            # Run OPA validation on the fresh plan
            opa eval -d "../opa-policies/terraform/" -i canonical-plan/plan.json \
              "data.terraform.main.validate_plan" --format json > pre-apply-opa-validation.json
            
            # Extract results
            violations=$(jq -r '.result[0].expressions[0].value.total_violations // 0' pre-apply-opa-validation.json)
            critical=$(jq -r '.result[0].expressions[0].value.critical_violations // 0' pre-apply-opa-validation.json)
            
            echo "üîç Pre-Apply Validation Results:"
            echo "   Total Violations: $violations"
            echo "   Critical: $critical"
            
            echo "violations=$violations" >> $GITHUB_OUTPUT
            echo "critical_violations=$critical" >> $GITHUB_OUTPUT
            
            if [ "$violations" -gt 0 ]; then
              echo "validation_status=failed" >> $GITHUB_OUTPUT
              echo "‚ùå Policy violations detected - apply will be blocked"
              # Save violation details for reporting
              jq -r '.result[0].expressions[0].value.violations' pre-apply-opa-validation.json > pre-apply-violations.json 2>/dev/null || echo "{}" > pre-apply-violations.json
            else
              echo "validation_status=passed" >> $GITHUB_OUTPUT
              echo "‚úÖ All policies passed - apply can proceed"
            fi
          else
            echo "validation_status=error" >> $GITHUB_OUTPUT
            echo "‚ùå Could not generate plan for pre-apply validation"
            echo "violations=0" >> $GITHUB_OUTPUT
            echo "critical_violations=0" >> $GITHUB_OUTPUT
          fi

      - name: üöÄ Terraform Apply
        if: steps.discover.outputs.has_deployments == 'true' && steps.pre_apply_validation.outputs.validation_status == 'passed'
        id: apply
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "üöÄ Running terraform apply..."
          echo "‚úÖ Pre-apply validation passed - proceeding with apply"
          
          set +e
          python3 ../controller/scripts/terraform-deployment-orchestrator.py apply \
            --deployments-json deployments.json --output-summary apply-results.json --debug --working-dir .
          apply_exit_code=$?
          set -e
          
          if [ -f apply-results.json ]; then
            total=$(jq -r '.total_deployments // 0' apply-results.json)
            successful=$(jq -r '.successful_applies // 0' apply-results.json)
            failed=$(jq -r '.failed_applies // 0' apply-results.json)
            
            echo "üìä Apply Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_applies=$successful" >> $GITHUB_OUTPUT
            echo "failed_applies=$failed" >> $GITHUB_OUTPUT
            
            if [ "$successful" -gt 0 ]; then
              echo "‚úÖ Apply completed with $successful successful deployments"
              exit 0
            else
              echo "‚ùå No deployments were successful"
              exit 1
            fi
          else
            echo "‚ùå No apply results found" && exit 1
          fi

      - name: ‚ùå Apply Blocked by Policy Violations
        if: steps.discover.outputs.has_deployments == 'true' && steps.pre_apply_validation.outputs.validation_status != 'passed'
        run: |
          echo "‚ùå APPLY BLOCKED - Policy violations detected"
          echo "üîç Violations: ${{ steps.pre_apply_validation.outputs.violations }}"
          echo "üö® Critical: ${{ steps.pre_apply_validation.outputs.critical_violations }}"
          echo ""
          echo "üõ°Ô∏è Apply process halted for security compliance"
          echo "üìù Fix violations in the source repository and retry"
          exit 1

      - name: üí¨ Post Apply Results
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const sourceRepo = '${{ github.event.client_payload.source_repo }}';
            const sourceOwner = '${{ github.event.client_payload.source_owner }}';
            const commitSha = '${{ github.event.client_payload.commit_sha }}';
            
            const total = '${{ steps.apply.outputs.total_deployments }}' || '0';
            const successful = '${{ steps.apply.outputs.successful_applies }}' || '0';
            const failed = '${{ steps.apply.outputs.failed_applies }}' || '0';
            
            let comment = `## üöÄ Terraform Apply Results\n\n`;
            comment += `**Repository**: \`${sourceRepo}\`\n`;
            comment += `**Commit**: \`${commitSha}\`\n\n`;
            comment += `### üìä Apply Summary\n`;
            comment += `‚úÖ Successful: ${successful}/${total}\n`;
            comment += `‚ùå Failed: ${failed}\n\n`;
            
            if (parseInt(successful) > 0) {
              comment += `üéâ **Infrastructure Successfully Deployed!**\n\n`;
            }
            
            if (parseInt(failed) > 0) {
              comment += `‚ö†Ô∏è **Some deployments failed** - please check the logs.\n\n`;
            }
            
            comment += `---\nü§ñ [View Run](https://github.com/Terraform-centilazed-pipline/centerlized-pipline-/actions/runs/${{ github.run_id }})`;
            
            // Create a commit comment instead of PR comment for apply results
            await github.rest.repos.createCommitComment({
              owner: sourceOwner,
              repo: sourceRepo,
              commit_sha: commitSha,
              body: comment
            });

      - name: üóëÔ∏è Delete Feature Branch After Successful Apply
        if: steps.apply.outputs.successful_applies > 0 && github.event.client_payload.source_ref != 'main' && github.event.client_payload.source_ref != 'master'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const sourceRepo = '${{ github.event.client_payload.source_repo }}';
            const sourceOwner = '${{ github.event.client_payload.source_owner }}';
            const branch = '${{ github.event.client_payload.source_ref }}';
            
            console.log(`üóëÔ∏è Attempting to delete branch: ${branch}`);
            
            try {
              await github.rest.git.deleteRef({
                owner: sourceOwner,
                repo: sourceRepo,
                ref: `heads/${branch}`
              });
              
              console.log(`‚úÖ Successfully deleted branch: ${branch}`);
              
              // Add a comment to the commit about branch deletion
              await github.rest.repos.createCommitComment({
                owner: sourceOwner,
                repo: sourceRepo,
                commit_sha: '${{ github.event.client_payload.commit_sha }}',
                body: `üóëÔ∏è **Branch Cleanup**: Feature branch \`${branch}\` has been automatically deleted after successful deployment.`
              });
              
            } catch (error) {
              console.log(`‚ö†Ô∏è Failed to delete branch ${branch}: ${error.message}`);
              // Don't fail the workflow if branch deletion fails
            }