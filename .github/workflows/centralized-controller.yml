# =============================================================================
# CENTRALIZED TERRAFORM CONTROLLER - The Real Deal!
# =============================================================================
# This workflow runs in the CENTRALIZED repo
# It listens for events from dev repos and does ALL the work
# Uses centralized main.tf, scripts, policies - dev repos just trigger it
# =============================================================================

name: Centralized Controller

on:
  repository_dispatch:
    types: [terraform_pr, terraform_apply]

permissions:
  id-token: write
  contents: read
  actions: read

env:
  TERRAFORM_VERSION: '1.11.0'
  OPA_VERSION: '0.59.0'
  AWS_REGION: 'us-east-1'

jobs:
  terraform-controller:
    name: üéØ Terraform Controller
    runs-on: ubuntu-latest
    if: github.event.action == 'terraform_pr' || github.event.client_payload.action != 'apply'
    steps:
      - name: üìã Event Details
        run: |
          echo "üîî Repository Dispatch Event Received"
          echo "Source Repo: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}"
          echo "PR Number: ${{ github.event.client_payload.pr_number }}"
          echo "PR Head: ${{ github.event.client_payload.pr_head_ref }}"
          echo "PR SHA: ${{ github.event.client_payload.pr_head_sha }}"
          echo "Action: ${{ github.event.client_payload.action }}"

      - name: Generate GitHub App Token
        id: app-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GT_APP_ID }}
          private_key: ${{ secrets.GT_APP_PRIVATE_KEY }}

      - name: Checkout Centralized Controller Repo
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/centerlized-pipline-
          path: controller
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout Source Dev Repo (PR branch)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}
          ref: ${{ github.event.client_payload.pr_head_ref }}
          path: source-repo
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout OPA Policies
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/OPA-Poclies
          path: opa-policies
          token: ${{ steps.app-token.outputs.token }}

      # Note: tf-module checkout removed - Terraform fetches modules from GitHub automatically
      # Module sources now use: git::https://github.com/Terraform-centilazed-pipline/tf-module.git//Module/<NAME>

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-controller

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # ===== OPTIMIZED TOOL SETUP (PARALLEL + CACHED) =====
      - name: ‚ö° Setup Tools (Parallel + Fast)
        id: setup-tools
        run: |
          echo "üöÄ Setting up OPA, yq, and Docker in parallel..."
          
          # Function to setup OPA with retries
          setup_opa() {
            echo "üì¶ Installing OPA ${{ env.OPA_VERSION }} with retries..."
            
            # Check if already available
            if command -v opa >/dev/null 2>&1; then
              echo "‚úÖ OPA already available"
              opa version
              return 0
            fi
            
            # Download with retries and fallback
            OPA_URL="https://openpolicyagent.org/downloads/v${{ env.OPA_VERSION }}/opa_linux_amd64_static"
            FALLBACK_URL="https://github.com/open-policy-agent/opa/releases/download/v${{ env.OPA_VERSION }}/opa_linux_amd64_static"
            
            for url in "$OPA_URL" "$FALLBACK_URL"; do
              echo "üì° Trying: $url"
              if timeout 30 curl -fsSL --connect-timeout 5 --max-time 30 -o opa "$url"; then
                chmod +x opa
                ./opa version
                sudo mv opa /usr/local/bin/
                echo "‚úÖ OPA installed successfully"
                return 0
              fi
              echo "‚ùå Failed, trying next URL..."
            done
            
            echo "‚ùå All OPA download attempts failed"
            return 1
          }
          
          # Function to setup yq with fallback
          setup_yq() {
            echo "üì¶ Installing yq..."
            
            # Check if already available
            if command -v yq >/dev/null 2>&1; then
              echo "‚úÖ yq already available"
              return 0
            fi
            
            # Try snap first (faster), then direct download
            if sudo snap install yq 2>/dev/null; then
              echo "‚úÖ yq installed via snap"
            elif timeout 15 curl -fsSL https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o yq; then
              chmod +x yq
              sudo mv yq /usr/local/bin/
              echo "‚úÖ yq installed via direct download"
            else
              echo "‚ùå yq installation failed"
              return 1
            fi
          }
          
          # Function to pre-pull Docker images
          setup_docker() {
            echo "üê≥ Pre-pulling Docker images..."
            
            # Pull Checkov image in background
            docker pull bridgecrew/checkov:latest &
            CHECKOV_PID=$!
            
            # Wait for Checkov (most important)
            if wait $CHECKOV_PID; then
              echo "‚úÖ Checkov image pulled successfully"
            else
              echo "‚ö†Ô∏è Checkov image pull failed (will retry during scan)"
            fi
          }
          
          # Run all setups in parallel
          echo "üîÑ Starting parallel tool setup..."
          setup_opa &
          OPA_PID=$!
          
          setup_yq &
          YQ_PID=$!
          
          setup_docker &
          DOCKER_PID=$!
          
          # Wait for critical tools
          wait $OPA_PID
          OPA_STATUS=$?
          
          wait $YQ_PID  
          YQ_STATUS=$?
          
          wait $DOCKER_PID
          DOCKER_STATUS=$?
          
          # Report results
          if [ $OPA_STATUS -eq 0 ] && [ $YQ_STATUS -eq 0 ]; then
            echo "‚úÖ All critical tools ready"
            echo "tools_ready=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Tool setup failed - OPA: $OPA_STATUS, yq: $YQ_STATUS"
            echo "tools_ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚ö° Tool setup completed in parallel!"

      - name: Configure Git Authentication for Terraform Modules
        run: |
          echo "üîß Configuring Git authentication for private Terraform modules..."
          git config --global url."https://oauth2:${{ steps.app-token.outputs.token }}@github.com".insteadOf "https://github.com"
          echo "‚úÖ Git authentication configured for Terraform module downloads"

      # ===== Get changed files from PR =====
      - name: üîç Get Changed Files
        id: changed-files
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              pull_number: ${{ github.event.client_payload.pr_number }}
            });
            
            const tfvarsFiles = files
              .filter(f => f.filename.match(/\.(tfvars|yaml|yml|json)$/))
              .filter(f => f.filename.startsWith('Accounts/') || f.filename.startsWith('configs/'))
              .map(f => f.filename);
            
            console.log('Changed files:', tfvarsFiles);
            core.setOutput('files', tfvarsFiles.join(' '));
            core.setOutput('count', tfvarsFiles.length);

      # ===== STEP 1: DISCOVER DEPLOYMENTS =====
      - name: üîç Discover Deployments
        if: steps.changed-files.outputs.count > 0
        id: discover
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --changed-files "${{ steps.changed-files.outputs.files }}" \
            --output-summary deployments.json \
            --debug
          
          total=$(jq -r '.total_deployments // 0' deployments.json)
          echo "total=$total" >> $GITHUB_OUTPUT
          
          if [ "$total" -gt 0 ]; then
            echo "‚úÖ Found $total deployments"
            echo "has_deployments=true" >> $GITHUB_OUTPUT
            
            # Extract first tfvars file for pre-validation
            first_tfvars=$(jq -r '.deployments[0].tfvars_file // empty' deployments.json)
            echo "first_tfvars=$first_tfvars" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No deployments found"
            echo "has_deployments=false" >> $GITHUB_OUTPUT
          fi

      # ===== STEP 2: PRE-DEPLOYMENT VALIDATION (BEFORE terraform plan) =====
      - name: üîç Pre-Deployment Validation
        if: steps.discover.outputs.has_deployments == 'true'
        id: pre_validation
        working-directory: source-repo
        continue-on-error: true
        run: |
          echo "üîç Running pre-deployment validation..."
          echo "üìÑ Validating: ${{ steps.discover.outputs.first_tfvars }}"
          echo "üë§ PR Author: ${{ github.event.client_payload.pr_author }}"
          
          # Run pre-deployment validator
          set +e
          python3 ../controller/scripts/pre-deployment-validator.py \
            "${{ steps.discover.outputs.first_tfvars }}" \
            "${{ github.event.client_payload.pr_author }}"
          
          validation_exit=$?
          set -e
          
          if [ -f pre-validation-comment.md ]; then
            echo "validation_comment_exists=true" >> $GITHUB_OUTPUT
          fi
          
          if [ $validation_exit -eq 0 ]; then
            echo "‚úÖ Pre-deployment validation passed"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Pre-deployment validation failed"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi
          
          exit $validation_exit

      - name: üí¨ Post Pre-Validation Comment
        if: steps.pre_validation.outputs.validation_comment_exists == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('source-repo/pre-validation-comment.md', 'utf8');
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: ${{ github.event.client_payload.pr_number }},
              body: comment
            });

      - name: üõë Stop if Pre-Validation Failed
        if: steps.pre_validation.outputs.validation_passed == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Close the PR
            await github.rest.pulls.update({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              pull_number: ${{ github.event.client_payload.pr_number }},
              state: 'closed'
            });
            
            core.setFailed('‚ùå Pre-deployment validation failed. PR closed.');

      # ===== STEP 2.5: CHECKOV SECURITY SCAN (OPTIMIZED) =====
      - name: üõ°Ô∏è Checkov Security Scan (Fast & Focused)
        if: steps.discover.outputs.has_deployments == 'true' && steps.setup-tools.outputs.tools_ready == 'true'
        id: checkov
        working-directory: source-repo
        continue-on-error: true
        run: |
          echo "üõ°Ô∏è Running optimized Checkov security scan..."
          
          # Create results directory
          mkdir -p checkov-results
          
          # Initialize counters
          total_issues=0
          critical_issues=0
          high_issues=0
          medium_issues=0
          
          # Use files from the discover step (it already found tfvars files)
          echo "üìÅ Scanning files discovered in previous step"
          DEPLOYMENT_FILES=$(jq -r '.deployments[].tfvars_file' deployments.json | tr '\n' ' ')
          echo "üìÅ Deployment files: $DEPLOYMENT_FILES"
          
          if [ -n "$DEPLOYMENT_FILES" ]; then
            echo "üîç Found .tfvars deployments to scan"
            echo "üìÑ Files: $DEPLOYMENT_FILES"
            
            # Fast YAML parsing (tools already installed)
            echo "üìã Loading security configuration..."
            
            CRITICAL_CHECKS=$(yq eval '.security_checks.critical[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
            HIGH_CHECKS=$(yq eval '.security_checks.high[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
            MEDIUM_CHECKS=$(yq eval '.security_checks.medium[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
            SKIP_CHECKS=$(yq eval '.skip_checks[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
            
            # Combine checks efficiently
            ALL_CHECKS="${CRITICAL_CHECKS},${HIGH_CHECKS},${MEDIUM_CHECKS}"
            
            echo "üéØ Focused scan - Critical: $(echo $CRITICAL_CHECKS | tr ',' '\n' | wc -l) checks"
            echo "üéØ Focused scan - High: $(echo $HIGH_CHECKS | tr ',' '\n' | wc -l) checks"
            echo "üéØ Focused scan - Medium: $(echo $MEDIUM_CHECKS | tr ',' '\n' | wc -l) checks"
            
            # Optimized Checkov command (pre-pulled image)
            echo "üèÉ‚Äç‚ôÇÔ∏è Running Checkov (optimized)..."
            
            CHECKOV_CMD="timeout 300 docker run --rm -v $PWD:/tf -v $PWD/../controller:/controller bridgecrew/checkov:latest \
              --framework terraform \
              --check $ALL_CHECKS \
              --output json \
              --output-file-path /tf/checkov-results/ \
              --quiet \
              --soft-fail \
              --var-file /controller/terraform.tfvars \
              --download-external-modules true \
              --compact \
              -d /controller"
            
            # Add skip checks if any
            if [ -n "$SKIP_CHECKS" ]; then
              CHECKOV_CMD="$CHECKOV_CMD --skip-check $SKIP_CHECKS"
            fi
            
            echo "üèÉ Executing scan..."
            eval "$CHECKOV_CMD" || true
            
            # Fast results processing
            if [ -f "checkov-results/results_json.json" ]; then
              echo "üìä Processing results (optimized)..."
              
              # Get thresholds
              CRITICAL_THRESHOLD=$(yq eval '.blocking_rules.critical_threshold' ../controller/checkov-config.yaml)
              HIGH_THRESHOLD=$(yq eval '.blocking_rules.high_threshold' ../controller/checkov-config.yaml)
              MEDIUM_THRESHOLD=$(yq eval '.blocking_rules.medium_threshold' ../controller/checkov-config.yaml)
              
              # Optimized counting with jq (faster than bash loops)
              critical_issues=$(jq --arg checks "$CRITICAL_CHECKS" '
                ($checks | split(",")) as $check_list |
                [.results.failed_checks[]? | select(.check_id | IN($check_list[]))] | length
              ' checkov-results/results_json.json 2>/dev/null || echo "0")
              
              high_issues=$(jq --arg checks "$HIGH_CHECKS" '
                ($checks | split(",")) as $check_list |
                [.results.failed_checks[]? | select(.check_id | IN($check_list[]))] | length
              ' checkov-results/results_json.json 2>/dev/null || echo "0")
              
              medium_issues=$(jq --arg checks "$MEDIUM_CHECKS" '
                ($checks | split(",")) as $check_list |
                [.results.failed_checks[]? | select(.check_id | IN($check_list[]))] | length
              ' checkov-results/results_json.json 2>/dev/null || echo "0")
              
              total_issues=$((critical_issues + high_issues + medium_issues))
              
              echo "üìä Fast Results:"
              echo "üî¥ Critical: $critical_issues (max: $CRITICAL_THRESHOLD)"
              echo "üü† High: $high_issues (max: $HIGH_THRESHOLD)" 
              echo "üü° Medium: $medium_issues (max: $MEDIUM_THRESHOLD)"
              echo "üìà Total: $total_issues"
              
              # Create dynamic summary
              {
                echo "=== CHECKOV SECURITY SCAN RESULTS ==="
                echo "Configuration: checkov-config.yaml"
                echo "Files Scanned: Controller .tf templates with changed .tfvars values"
                echo "Critical Issues: $critical_issues (threshold: $CRITICAL_THRESHOLD)"
                echo "High Issues: $high_issues (threshold: $HIGH_THRESHOLD)"
                echo "Medium Issues: $medium_issues (threshold: $MEDIUM_THRESHOLD)"
                echo "Total Issues: $total_issues"
                echo ""
                if [ "$critical_issues" -gt "$CRITICAL_THRESHOLD" ]; then
                  echo "‚ùå CRITICAL SECURITY ISSUES FOUND"
                  echo "Details:"
                  jq --arg checks "$CRITICAL_CHECKS" -r '.results.failed_checks[]? | select(.check_id | test($checks | split(",") | join("|"))) | "- " + .check_name + " (" + .check_id + "): " + .file_path' checkov-results/results_json.json 2>/dev/null || echo "See full results above"
                elif [ "$high_issues" -gt "$HIGH_THRESHOLD" ]; then
                  echo "‚ö†Ô∏è TOO MANY HIGH SEVERITY ISSUES"
                  echo "Details:"
                  jq --arg checks "$HIGH_CHECKS" -r '.results.failed_checks[]? | select(.check_id | test($checks | split(",") | join("|"))) | "- " + .check_name + " (" + .check_id + "): " + .file_path' checkov-results/results_json.json 2>/dev/null || echo "See full results above"
                else
                  echo "‚úÖ Security scan passed thresholds"
                fi
              } > checkov-summary.txt
              
              cat checkov-summary.txt
              
              # Save critical and high severity details for PR comment
              {
                if [ "$critical_issues" -gt 0 ]; then
                  echo "=== CRITICAL SECURITY ISSUES ==="
                  jq --arg checks "$CRITICAL_CHECKS" -r '.results.failed_checks[]? | select(.check_id | test($checks | split(",") | join("|"))) | "üî¥ " + .check_name + " (" + .check_id + ")\n   File: " + .file_path + "\n   Description: " + .description + "\n"' checkov-results/results_json.json 2>/dev/null || echo "No critical issues details available"
                  echo ""
                fi
                
                if [ "$high_issues" -gt 0 ]; then
                  echo "=== HIGH SEVERITY ISSUES ==="
                  jq --arg checks "$HIGH_CHECKS" -r '.results.failed_checks[]? | select(.check_id | test($checks | split(",") | join("|"))) | "üü† " + .check_name + " (" + .check_id + ")\n   File: " + .file_path + "\n   Description: " + .description + "\n"' checkov-results/results_json.json 2>/dev/null || echo "No high issues details available"
                fi
              } > checkov-critical-high.txt
            else
              echo "‚ö†Ô∏è No Checkov results - controller templates may not exist or scan failed"
            fi
          else
            echo "‚ÑπÔ∏è No .tfvars deployments found - skipping security scan"
            echo "üìã Available deployments.json contents:"
            cat deployments.json 2>/dev/null || echo "No deployments.json file found"
          fi
          
          # Set outputs for downstream steps
          echo "total_issues=$total_issues" >> $GITHUB_OUTPUT
          echo "critical_issues=$critical_issues" >> $GITHUB_OUTPUT
          echo "high_issues=$high_issues" >> $GITHUB_OUTPUT
          echo "medium_issues=$medium_issues" >> $GITHUB_OUTPUT
          
          # Determine scan status using dynamic thresholds from config
          if [ "$critical_issues" -gt "${CRITICAL_THRESHOLD:-0}" ]; then
            echo "scan_status=failed" >> $GITHUB_OUTPUT
            echo "scan_message=üî¥ Critical security issues found (${critical_issues}>${CRITICAL_THRESHOLD})" >> $GITHUB_OUTPUT
          elif [ "$high_issues" -gt "${HIGH_THRESHOLD:-5}" ]; then
            echo "scan_status=failed" >> $GITHUB_OUTPUT  
            echo "scan_message=‚ö†Ô∏è Too many high severity issues (${high_issues}>${HIGH_THRESHOLD})" >> $GITHUB_OUTPUT
          elif [ "$medium_issues" -gt "${MEDIUM_THRESHOLD:-10}" ]; then
            echo "scan_status=warning" >> $GITHUB_OUTPUT
            echo "scan_message=‚ö†Ô∏è Multiple medium issues found (${medium_issues}>${MEDIUM_THRESHOLD})" >> $GITHUB_OUTPUT
          else
            echo "scan_status=passed" >> $GITHUB_OUTPUT
            echo "scan_message=‚úÖ Security scan passed all thresholds" >> $GITHUB_OUTPUT
          fi
          
          echo "üõ°Ô∏è Checkov security scan completed"

      # ===== STEP 2B: TERRAFORM FORMAT CHECK =====
      - name: üìù Terraform Format Check
        if: steps.discover.outputs.has_deployments == 'true'
        id: fmt
        working-directory: controller
        run: |
          echo "üìù Running terraform fmt check..."
          
          # Initialize variables
          fmt_issues=0
          fmt_files=""
          
          # Check format (dry run first)
          echo "üîç Checking Terraform format..."
          if ! terraform fmt -check -recursive -diff; then
            echo "‚ö†Ô∏è Format issues found - fixing automatically..."
            
            # Get list of files that need formatting
            fmt_files=$(terraform fmt -write=false -list=true -recursive | tr '\n' ' ')
            fmt_issues=$(terraform fmt -write=false -list=true -recursive | wc -l)
            
            # Auto-fix formatting
            terraform fmt -recursive
            
            echo "‚úÖ Format fixes applied to $fmt_issues files"
            echo "üìÅ Files formatted: $fmt_files"
            
            # Save formatting details for PR comment
            {
              echo "=== TERRAFORM FORMAT FIXES ==="
              echo "Files automatically formatted: $fmt_issues"
              echo "Files: $fmt_files"
              echo ""
              echo "Changes applied:"
              terraform fmt -check -recursive -diff 2>&1 || true
            } > ../source-repo/terraform-fmt-result.txt
          else
            echo "‚úÖ All Terraform files are properly formatted"
            echo "=== TERRAFORM FORMAT CHECK ===" > ../source-repo/terraform-fmt-result.txt
            echo "‚úÖ All files properly formatted" >> ../source-repo/terraform-fmt-result.txt
          fi
          
          # Set outputs
          echo "fmt_issues=$fmt_issues" >> $GITHUB_OUTPUT
          echo "fmt_files=$fmt_files" >> $GITHUB_OUTPUT
          
          echo "üìù Terraform format check completed"

      # ===== STEP 3: TERRAFORM PLAN WITH STATE INFO =====
      - name: üìã Terraform Plan with State Analysis
        if: steps.discover.outputs.has_deployments == 'true'
        id: plan
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "üìã Running terraform plan for multiple deployments..."
          echo "üîß Terraform directory: $TERRAFORM_DIR"
          
          # Initialize working directory and terraform
          cd $TERRAFORM_DIR
          echo "üîß Initializing Terraform..."
          terraform init -input=false -no-color
          
          # Generate state list BEFORE planning
          echo "üìã Generating current state information..."
          {
            echo "=== TERRAFORM STATE LIST (BEFORE PLAN) ==="
            echo "Current resources in state:"
            terraform state list 2>/dev/null || echo "No resources in state yet"
            echo ""
          } > ../source-repo/terraform-state-info.txt
          
          cd ../source-repo
          
          # Use the deployment orchestrator to run plans and create artifacts
          # This handles multiple deployments from different accounts properly
          set +e  # Don't exit on error - we want to show results even if some plans fail
          python3 ../controller/scripts/terraform-deployment-orchestrator.py plan \
            --deployments-json deployments.json \
            --output-summary plan-results.json \
            --debug
          
          plan_exit_code=$?
          set -e  # Re-enable exit on error
          
          echo "üîç Deployment manager exit code: $plan_exit_code"
          
          if [ -f plan-results.json ]; then
            total=$(jq -r '.total_deployments // 0' plan-results.json)
            successful=$(jq -r '.successful_plans // 0' plan-results.json)
            failed=$(jq -r '.failed_plans // 0' plan-results.json)
            has_changes=$(jq -r '.has_changes // false' plan-results.json)
            
            echo "üìä Plan Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_plans=$successful" >> $GITHUB_OUTPUT
            echo "failed_plans=$failed" >> $GITHUB_OUTPUT
            echo "has_changes=$has_changes" >> $GITHUB_OUTPUT
            
            # Select first plan for OPA validation
            if [ -d "terraform-json" ] && [ "$successful" -gt 0 ]; then
              mkdir -p canonical-plan
              FIRST_JSON=$(ls terraform-json/*.json 2>/dev/null | head -n1)
              if [ -n "$FIRST_JSON" ]; then
                cp "$FIRST_JSON" canonical-plan/plan.json
                echo "‚úÖ Selected plan for OPA: $FIRST_JSON"
                echo "opa_plan_ready=true" >> $GITHUB_OUTPUT
              else
                echo "‚ö†Ô∏è No JSON plans found for OPA validation"
                echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ö†Ô∏è No successful plans for OPA validation"
              echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
            fi
            
            # Continue workflow even if some plans failed
            if [ "$successful" -gt 0 ]; then
              echo "‚úÖ Continuing workflow with $successful successful plans"
              exit 0
            else
              echo "‚ùå No plans were successful"
              exit 1
            fi
          else
            echo "‚ùå No plan-results.json found"
            exit 1
          fi

      # ===== STEP 3B: POST-PLAN STATE & GRAPH ANALYSIS =====
      - name: üìä Generate State List & Terraform Graph
        if: steps.plan.outputs.successful_plans > 0
        id: state-graph
        working-directory: controller
        run: |
          echo "üìä Generating post-plan state analysis and graph..."
          
          # Generate updated state list
          {
            echo ""
            echo "=== TERRAFORM STATE LIST (AFTER PLAN) ==="
            echo "Resources that will be in state after apply:"
            terraform state list 2>/dev/null || echo "No resources in state yet"
            
            # Show state details for key resources
            echo ""
            echo "=== KEY RESOURCE DETAILS ==="
            terraform state list 2>/dev/null | head -10 | while read resource; do
              if [ -n "$resource" ]; then
                echo "Resource: $resource"
                terraform state show "$resource" 2>/dev/null | head -5 || echo "  Details not available"
                echo ""
              fi
            done 2>/dev/null || echo "No detailed state information available"
            
          } >> ../source-repo/terraform-state-info.txt
          
          # Generate Terraform dependency graph
          echo "üéØ Generating Terraform dependency graph..."
          {
            echo ""
            echo "=== TERRAFORM DEPENDENCY GRAPH ==="
            echo "Infrastructure dependency visualization:"
            echo ""
            terraform graph -type=plan 2>/dev/null || echo "Graph generation failed - likely no changes planned"
          } > ../source-repo/terraform-graph.txt
          
          # Generate resource count summary
          total_resources=$(terraform state list 2>/dev/null | wc -l || echo "0")
          echo "üìà State summary: $total_resources total resources"
          
          # Set outputs for PR comment
          echo "total_resources=$total_resources" >> $GITHUB_OUTPUT
          
          echo "üìä State and graph analysis completed"

      # ===== STEP 4: OPA VALIDATION =====
      - name: üõ°Ô∏è OPA Validation
        if: steps.plan.outputs.opa_plan_ready == 'true'
        id: opa
        working-directory: source-repo
        run: |
          echo "üõ°Ô∏è Running OPA validation on canonical plan..."
          echo "üìÅ Using multi-service policy structure: terraform/main.rego"
          
          if [ ! -f "canonical-plan/plan.json" ]; then
            echo "‚ùå No canonical plan found"
            exit 1
          fi
          
          # Basic plan analysis
          echo "ÔøΩ Plan analysis:"
          echo "   File size: $(wc -c < canonical-plan/plan.json) bytes"
          echo "   Resource changes: $(jq -r '.resource_changes | length' canonical-plan/plan.json 2>/dev/null || echo "0")"
          
          # Get deployment summary (which services are being deployed)
          echo "üì¶ Detecting services in plan..."
          opa eval -d ../opa-policies/terraform/ \
            -i canonical-plan/plan.json \
            "data.terraform.main.deployment_summary" \
            --format pretty > opa-summary.txt || true
          
          services_detected=$(opa eval -d ../opa-policies/terraform/ \
            -i canonical-plan/plan.json \
            "data.terraform.main.deployment_summary.services_detected" \
            --format json | jq -r '.result[0].expressions[0].value[]?' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
          
          if [ -n "$services_detected" ]; then
            echo "üì¶ Services detected: $services_detected"
          else
            echo "‚ÑπÔ∏è No specific services detected, will run all policies"
          fi
          
          # Run unified OPA validation (auto-detects and validates all services)
          echo "üîç Running policy validation..."
          opa eval -d ../opa-policies/terraform/ \
            -i canonical-plan/plan.json \
            "data.terraform.main.deny" \
            --format pretty > opa-result.txt || true
          
          # Count violations by severity  
          violations_json=$(opa eval -d ../opa-policies/terraform/ \
            -i canonical-plan/plan.json \
            "data.terraform.main.deny" \
            --format json 2>/dev/null || echo '{"result":[{"expressions":[{"value":{}}]}]}')
          
          # Parse violations from OPA object format - violations are stored as keys in the object
          total_violations=$(echo "$violations_json" | jq -r '
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object")] | length' 2>/dev/null || echo "0")
             
          critical_violations=$(echo "$violations_json" | jq -r '
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object" and .severity == "critical")] | length' 2>/dev/null || echo "0")
             
          high_violations=$(echo "$violations_json" | jq -r '
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object" and .severity == "high")] | length' 2>/dev/null || echo "0")
             
          medium_violations=$(echo "$violations_json" | jq -r '
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object" and .severity == "medium")] | length' 2>/dev/null || echo "0")
             
          low_violations=$(echo "$violations_json" | jq -r '
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object" and .severity == "low")] | length' 2>/dev/null || echo "0")
          
          # Ensure variables are numeric (default to 0 if empty, remove any whitespace/newlines)
          total_violations=$(echo "${total_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          critical_violations=$(echo "${critical_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          high_violations=$(echo "${high_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          medium_violations=$(echo "${medium_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          low_violations=$(echo "${low_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          
          echo ""
          echo "üìä Validation Results:"
          echo "   Total violations: $total_violations"
          echo "   üî¥ Critical: $critical_violations"
          echo "   üü† High: $high_violations"
          echo "   üü° Medium: $medium_violations"
          echo "   üü¢ Low: $low_violations"
          
          # Set outputs
          echo "total_violations=$total_violations" >> $GITHUB_OUTPUT
          echo "critical_violations=$critical_violations" >> $GITHUB_OUTPUT
          echo "high_violations=$high_violations" >> $GITHUB_OUTPUT
          echo "medium_violations=$medium_violations" >> $GITHUB_OUTPUT
          echo "low_violations=$low_violations" >> $GITHUB_OUTPUT
          echo "services_detected=$services_detected" >> $GITHUB_OUTPUT
          
          if [ "$total_violations" -eq 0 ]; then
            echo "validation_status=passed" >> $GITHUB_OUTPUT
            echo ""
            echo "‚úÖ All policies passed - deployment authorized!"
          else
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            echo ""
            echo "‚ùå Validation failed: $total_violations violations found"
            echo ""
            echo "üìã Violation Details:"
            cat opa-result.txt
          fi

      # ===== STEP 4: POST PR COMMENT WITH NOTIFICATIONS =====
      - name: üí¨ Post PR Comment with User Notification
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const prAuthor = '${{ github.event.client_payload.pr_author }}';
            const sourceRepo = '${{ github.event.client_payload.source_repo }}';
            const prNumber = '${{ github.event.client_payload.pr_number }}';
            const prUrl = '${{ github.event.client_payload.pr_url }}';
            const prBranch = '${{ github.event.client_payload.pr_head_ref }}';
            
            let comment = `## üöÄ Centralized Terraform Controller Results\n\n`;
            comment += `**üë§ PR Author**: @${prAuthor}\n`;
            comment += `**Source Repo**: \`${sourceRepo}\`\n`;
            comment += `**PR**: [#${prNumber}](${prUrl})\n`;
            comment += `**Branch**: \`${prBranch}\`\n\n`;
            
            // Checkov Security Scan Results
            const checkovStatus = '${{ steps.checkov.outputs.scan_status }}';
            const checkovMessage = '${{ steps.checkov.outputs.scan_message }}';
            const totalIssues = '${{ steps.checkov.outputs.total_issues }}';
            const criticalIssues = '${{ steps.checkov.outputs.critical_issues }}';
            const highIssues = '${{ steps.checkov.outputs.high_issues }}';
            const mediumIssues = '${{ steps.checkov.outputs.medium_issues }}';
            
            if (checkovStatus) {
              comment += `### üõ°Ô∏è Security Scan Results\n`;
              comment += `**Status**: ${checkovMessage}\n\n`;
              
              if (totalIssues && totalIssues !== '0') {
                comment += `| Severity | Count |\n`;
                comment += `|----------|-------|\n`;
                comment += `| üî¥ Critical | ${criticalIssues || '0'} |\n`;
                comment += `| üü† High | ${highIssues || '0'} |\n`;
                comment += `| üü° Medium | ${mediumIssues || '0'} |\n`;
                comment += `| üìä **Total** | **${totalIssues}** |\n\n`;
                
                // Add critical/high issue details if available
                try {
                  const checkovDetails = fs.readFileSync('source-repo/checkov-critical-high.txt', 'utf8');
                  if (checkovDetails && checkovDetails.trim()) {
                    comment += `<details>\n<summary>üîç Critical & High Severity Issues (Click to expand)</summary>\n\n`;
                    comment += `\`\`\`\n${checkovDetails}\n\`\`\`\n\n</details>\n\n`;
                  }
                } catch (e) {
                  console.log('No detailed checkov results file found');
                }
                
                // Add notification for critical/high issues
                if (criticalIssues && parseInt(criticalIssues) > 0) {
                  comment += `> üö® **URGENT @${prAuthor}**: Critical security issues detected! Please review and fix before merging.\n\n`;
                } else if (highIssues && parseInt(highIssues) > 2) {
                  comment += `> ‚ö†Ô∏è **Warning @${prAuthor}**: Multiple high severity security issues detected. Please review.\n\n`;
                }
              } else {
                comment += `‚úÖ No security issues detected by Checkov scan.\n\n`;
              }
            }
            
            // Plan results
            const total = '${{ steps.plan.outputs.total_deployments }}';
            const successful = '${{ steps.plan.outputs.successful_plans }}';
            const failed = '${{ steps.plan.outputs.failed_plans }}';
            const hasChanges = '${{ steps.plan.outputs.has_changes }}';
            
            if (total && total !== '0') {
              comment += `### üìä Terraform Plan Summary\n`;
              comment += `| Metric | Count |\n`;
              comment += `|--------|-------|\n`;
              comment += `| üìã Total Deployments | ${total} |\n`;
              comment += `| ‚úÖ Successful Plans | ${successful} |\n`;
              comment += `| ‚ùå Failed Plans | ${failed} |\n`;
              comment += `| üîÑ Has Changes | ${hasChanges === 'true' ? 'Yes' : 'No'} |\n\n`;
              
              // Add detailed plan results if available
              try {
                const planResults = fs.readFileSync('source-repo/plan-results.json', 'utf8');
                const results = JSON.parse(planResults);
                
                if (results.plans && results.plans.length > 0) {
                  comment += `### üìã Deployment Details\n`;
                  comment += `| Deployment | Status | Changes |\n`;
                  comment += `|------------|--------|----------|\n`;
                  
                  results.plans.forEach(plan => {
                    const status = plan.status === 'success' ? '‚úÖ' : '‚ùå';
                    const changes = plan.has_changes ? 'üîÑ Yes' : '‚ûñ None';
                    comment += `| ${plan.deployment} | ${status} | ${changes} |\n`;
                  });
                  comment += `\n`;
                }
                
                // Add plan markdown if available
                const planMarkdownDir = 'source-repo/plan-markdown';
                if (fs.existsSync(planMarkdownDir)) {
                  const markdownFiles = fs.readdirSync(planMarkdownDir).filter(f => f.endsWith('.md'));
                  
                  if (markdownFiles.length > 0) {
                    comment += `### üîß Terraform Plans\n`;
                    markdownFiles.forEach(file => {
                      const content = fs.readFileSync(`${planMarkdownDir}/${file}`, 'utf8');
                      // Truncate if too long
                      const truncated = content.length > 5000 ? content.substring(0, 5000) + '\n... (truncated)' : content;
                      comment += truncated + '\n\n';
                    });
                  }
                }
              } catch (e) {
                console.log('Could not read plan results:', e.message);
              }
            } else {
              comment += `### üìã Terraform Plan\n`;
              comment += `‚ÑπÔ∏è No deployments found or no changes detected\n\n`;
            }
            
            // Terraform Format Results
            const fmtIssues = '${{ steps.fmt.outputs.fmt_issues }}';
            const fmtFiles = '${{ steps.fmt.outputs.fmt_files }}';
            
            comment += `### üìù Terraform Format Check\n`;
            if (fmtIssues && fmtIssues !== '0') {
              comment += `‚ö†Ô∏è **Format Issues Fixed**: ${fmtIssues} files automatically formatted\n`;
              comment += `üìÅ **Files**: ${fmtFiles}\n\n`;
              
              try {
                const fmtDetails = fs.readFileSync('source-repo/terraform-fmt-result.txt', 'utf8');
                comment += `<details>\n<summary>üîç Format Changes (Click to expand)</summary>\n\n`;
                comment += `\`\`\`diff\n${fmtDetails}\n\`\`\`\n\n</details>\n\n`;
              } catch (e) {
                console.log('No format details file found');
              }
            } else {
              comment += `‚úÖ All Terraform files are properly formatted\n\n`;
            }
            
            // State List and Graph Information
            const totalResources = '${{ steps.state-graph.outputs.total_resources }}';
            
            comment += `### üìä Infrastructure State & Graph\n`;
            comment += `üìà **Total Resources in State**: ${totalResources || '0'}\n\n`;
            
            // Add state information
            try {
              const stateInfo = fs.readFileSync('source-repo/terraform-state-info.txt', 'utf8');
              if (stateInfo && stateInfo.trim()) {
                comment += `<details>\n<summary>üìã State Resources (Click to expand)</summary>\n\n`;
                comment += `\`\`\`\n${stateInfo}\n\`\`\`\n\n</details>\n\n`;
              }
            } catch (e) {
              comment += `‚ÑπÔ∏è State information not available\n\n`;
            }
            
            // Add terraform graph
            try {
              const graphInfo = fs.readFileSync('source-repo/terraform-graph.txt', 'utf8');
              if (graphInfo && graphInfo.trim()) {
                comment += `<details>\n<summary>üéØ Infrastructure Dependency Graph (Click to expand)</summary>\n\n`;
                comment += `\`\`\`dot\n${graphInfo}\n\`\`\`\n\n</details>\n\n`;
              }
            } catch (e) {
              comment += `‚ÑπÔ∏è Dependency graph not available\n\n`;
            }
            
            // OPA results
            const validation = '${{ steps.opa.outputs.validation_status }}';
            const violations = '${{ steps.opa.outputs.total_violations }}';
            
            comment += `### üõ°Ô∏è OPA Policy Validation\n`;
            if (validation === 'passed') {
              comment += `‚úÖ **Status**: PASSED - No policy violations\n\n`;
            } else if (validation === 'failed') {
              comment += `‚ùå **Status**: FAILED\n`;
              comment += `- **Violations**: ${violations}\n\n`;
              try {
                const opaResult = fs.readFileSync('source-repo/opa-result.txt', 'utf8');
                comment += `\`\`\`\n${opaResult}\n\`\`\`\n\n`;
              } catch (e) {}
            } else if ('${{ steps.plan.outputs.opa_plan_ready }}' === 'false') {
              comment += `‚ö†Ô∏è **Status**: SKIPPED - No successful plans for validation\n\n`;
            }
            
            comment += `\n---\n`;
            comment += `ü§ñ *Centralized Controller* | `;
            comment += `[View Run](https://github.com/Terraform-centilazed-pipline/centerlized-pipline-/actions/runs/${{ github.run_id }})`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: ${{ github.event.client_payload.pr_number }},
              body: comment
            });

      # ===== STEP 4B: IMMEDIATE NOTIFICATIONS FOR CRITICAL ISSUES =====
      - name: üö® Send Critical Security Alert  
        if: steps.checkov.outputs.scan_status == 'failed' && steps.checkov.outputs.critical_issues > 0
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Send a separate immediate notification for critical issues
            const prAuthor = '${{ github.event.client_payload.pr_author }}';
            const criticalCount = '${{ steps.checkov.outputs.critical_issues }}';
            const sourceRepo = '${{ github.event.client_payload.source_repo }}';
            const prNumber = '${{ github.event.client_payload.pr_number }}';
            
            const alertComment = `üö® **URGENT SECURITY ALERT** üö®\n\n` +
              `@${prAuthor} - **${criticalCount} Critical Security Issues** detected in your Terraform changes!\n\n` +
              `‚õî **Action Required**: Please fix these critical issues before proceeding.\n\n` +
              `üìã See full details in the comment above.\n\n` +
              `---\n` +
              `üîí *Automated Security Alert*`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: prNumber,
              body: alertComment
            });
            
            console.log(`Critical security alert sent to @${prAuthor} for ${criticalCount} critical issues`);

      # ===== STEP 5: AUTO-MERGE OR CLOSE PR =====
      - name: üîÄ Handle PR - Auto-merge if Security & OPA Passed
        if: steps.opa.outputs.validation_status != ''
        id: merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const validation = '${{ steps.opa.outputs.validation_status }}';
            const checkovStatus = '${{ steps.checkov.outputs.scan_status }}';
            const criticalIssues = '${{ steps.checkov.outputs.critical_issues }}';
            const highIssues = '${{ steps.checkov.outputs.high_issues }}';
            const owner = '${{ github.event.client_payload.source_owner }}';
            const repo = '${{ github.event.client_payload.source_repo }}';
            const pr_number = ${{ github.event.client_payload.pr_number }};
            
            console.log(`OPA Validation Status: ${validation}`);
            console.log(`Checkov Status: ${checkovStatus}`);
            console.log(`Critical Issues: ${criticalIssues}, High Issues: ${highIssues}`);
            
            // Check if both security and policy validation passed
            const securityPassed = checkovStatus === 'passed' || (checkovStatus === 'warning' && parseInt(criticalIssues || '0') === 0);
            const opaPassed = validation === 'passed';
            
            if (opaPassed && securityPassed) {
              console.log('‚úÖ Both OPA and Security validation passed - auto-merging PR');
              
              try {
                const { data: mergeResult } = await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr_number,
                  merge_method: 'squash',
                  commit_title: '[Terraform] Auto-approved: Security & OPA validation passed',
                  commit_message: 'Automatically merged after successful security scan and OPA policy validation.\n\nAll security policies and compliance checks passed. Terraform changes approved for deployment.'
                });
                
                console.log('‚úÖ PR merged successfully');
                console.log('Merge SHA:', mergeResult.sha);
                
                // Set output for triggering apply job
                core.setOutput('merged', 'true');
                core.setOutput('merge_sha', mergeResult.sha);
                
                // Add success comment
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr_number,
                  body: `‚úÖ **PR Auto-Approved & Merged!**\n\n` +
                        `üõ°Ô∏è Security Scan: ${checkovStatus === 'passed' ? 'PASSED' : 'WARNING (no critical issues)'}\n` +
                        `üîí OPA Policy Validation: PASSED\n` +
                        `üìã Services validated: ${{ steps.opa.outputs.services_detected || 'All services' }}\n` +
                        `üîÄ Changes have been merged to \`main\`\n` +
                        `üöÄ Terraform apply will begin automatically...\n\n` +
                        `**Merge SHA**: \`${mergeResult.sha}\``
                });
                
              } catch (error) {
                console.log('‚ùå Could not merge:', error.message);
                core.setOutput('merged', 'false');
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr_number,
                  body: `‚ö†Ô∏è **Auto-merge Failed**\n\nSecurity and OPA validation passed, but automatic merge failed.\n\nError: ${error.message}\n\nPlease merge manually.`
                });
              }
            } else if (!securityPassed) {
              console.log('‚ùå Security scan failed - closing PR');
              
              core.setOutput('merged', 'false');
              
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr_number,
                state: 'closed'
              });
              
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr_number,
                body: `‚ùå **PR Closed: Security Issues Detected**\n\n` +
                      `ÔøΩ **@${{ github.event.client_payload.pr_author }}** - Your PR has been automatically closed due to security issues.\n\n` +
                      `ÔøΩüõ°Ô∏è Checkov security scan found **${criticalIssues || '0'} critical issues**\n\n` +
                      `**Security Issue Summary**:\n` +
                      `- üî¥ Critical: ${criticalIssues || '0'}\n` +
                      `- üü† High: ${highIssues || '0'}\n` +
                      `- üü° Medium: ${{ steps.checkov.outputs.medium_issues || '0' }}\n\n` +
                      `**Action Required**: Fix critical security issues before re-opening PR.\n` +
                      `**Review**: Check the security scan results above for detailed remediation steps.`
              });
            } else if (validation === 'failed') {
              console.log('‚ùå OPA failed - closing PR');
              
              core.setOutput('merged', 'false');
              
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr_number,
                state: 'closed'
              });
              
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr_number,
                body: `‚ùå **PR Closed: Policy Violations**\n\n` +
                      `ÔøΩ **@${{ github.event.client_payload.pr_author }}** - Your PR has been automatically closed due to policy violations.\n\n` +
                      `ÔøΩüõ°Ô∏è OPA validation failed with **${{ steps.opa.outputs.total_violations }} violations**\n\n` +
                      `**Severity Breakdown**:\n` +
                      `- üî¥ Critical: ${{ steps.opa.outputs.critical_violations }}\n` +
                      `- üü† High: ${{ steps.opa.outputs.high_violations }}\n` +
                      `- üü° Medium: ${{ steps.opa.outputs.medium_violations }}\n` +
                      `- üü¢ Low: ${{ steps.opa.outputs.low_violations }}\n\n` +
                      `**Services Validated**: ${{ steps.opa.outputs.services_detected || 'All' }}\n\n` +
                      `**Required Actions**:\n` +
                      `1. Review the OPA validation results above\n` +
                      `2. Fix all policy violations in your configuration\n` +
                      `3. Create a new PR with corrected changes\n\n` +
                      `---\n` +
                      `*Security policies must pass before changes can be merged.*`
              });
              
              console.log('‚ùå PR closed due to policy violations');
            }

      # ===== STEP 6: TRIGGER TERRAFORM APPLY (after successful merge) =====
      - name: üöÄ Trigger Terraform Apply
        if: steps.merge.outputs.merged == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            console.log('üöÄ Triggering Terraform Apply workflow...');
            
            // Dispatch apply event to this same workflow
            await github.rest.repos.createDispatchEvent({
              owner: 'Terraform-centilazed-pipline',
              repo: 'centerlized-pipline-',
              event_type: 'terraform_apply',
              client_payload: {
                source_owner: '${{ github.event.client_payload.source_owner }}',
                source_repo: '${{ github.event.client_payload.source_repo }}',
                pr_number: ${{ github.event.client_payload.pr_number }},
                pr_url: '${{ github.event.client_payload.pr_url }}',
                merge_commit_sha: '${{ steps.merge.outputs.merge_sha }}',
                action: 'apply',
                merged: 'true'
              }
            });
            
            console.log('‚úÖ Apply workflow triggered');

      # ===== UPLOAD ARTIFACTS =====
      - name: üì¶ Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-controller-results
          path: |
            source-repo/deployments.json
            source-repo/plan-results.json
            source-repo/terraform-json/
            source-repo/plan-markdown/
            source-repo/canonical-plan/
            source-repo/plans/
            source-repo/logs/
            source-repo/opa-result.txt
            source-repo/*.log

  # =============================================================================
  # TERRAFORM APPLY JOB - Runs after PR is merged (auto-merge after OPA passed)
  # =============================================================================
  terraform-apply:
    name: üöÄ Terraform Apply (Post-Merge)
    runs-on: ubuntu-latest
    if: github.event.action == 'terraform_apply' || (github.event.client_payload.action == 'apply' && github.event.client_payload.merged == 'true')
    steps:
      - name: üìã Apply Event Details
        run: |
          echo "üöÄ Terraform Apply Event Received"
          echo "Source Repo: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}"
          echo "PR Number: ${{ github.event.client_payload.pr_number }}"
          echo "Merged SHA: ${{ github.event.client_payload.merge_commit_sha }}"
          echo "Action: ${{ github.event.client_payload.action }}"

      - name: Generate GitHub App Token
        id: app-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GT_APP_ID }}
          private_key: ${{ secrets.GT_APP_PRIVATE_KEY }}

      - name: Checkout Centralized Controller Repo
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/centerlized-pipline-
          path: controller
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout Source Dev Repo (main/merged branch)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}
          ref: main
          path: source-repo
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout OPA Policies
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/OPA-Poclies
          path: opa-policies
          token: ${{ steps.app-token.outputs.token }}

      # Note: tf-module checkout removed - Terraform fetches modules from GitHub automatically
      # Module sources now use: git::https://github.com/Terraform-centilazed-pipline/tf-module.git//Module/<NAME>

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          pip install pyyaml boto3 jinja2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-apply

      - name: Configure Git Authentication for Terraform Modules
        run: |
          echo "üîß Configuring Git authentication for private Terraform modules..."
          git config --global url."https://oauth2:${{ steps.app-token.outputs.token }}@github.com".insteadOf "https://github.com"
          echo "‚úÖ Git authentication configured for Terraform module downloads"

      - name: Get Merged PR Files
        id: merged-files
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              pull_number: ${{ github.event.client_payload.pr_number }}
            });
            
            const tfvarsFiles = files
              .filter(f => f.filename.match(/\.(tfvars|yaml|yml|json)$/))
              .filter(f => f.filename.startsWith('Accounts/') || f.filename.startsWith('configs/'))
              .map(f => f.filename);
            
            console.log('Merged PR files:', tfvarsFiles);
            core.setOutput('files', tfvarsFiles.join(' '));
            core.setOutput('count', tfvarsFiles.length);

      - name: üîç Discover Deployments for Apply
        if: steps.merged-files.outputs.count > 0
        id: discover
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "üîç Discovering deployments from merged PR..."
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --changed-files "${{ steps.merged-files.outputs.files }}" \
            --output-summary deployments.json \
            --debug
          
          total=$(jq -r '.total_deployments // 0' deployments.json)
          echo "total=$total" >> $GITHUB_OUTPUT
          
          if [ "$total" -gt 0 ]; then
            echo "‚úÖ Found $total deployments to apply"
            echo "has_deployments=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No deployments found"
            echo "has_deployments=false" >> $GITHUB_OUTPUT
          fi

      - name: üöÄ Terraform Apply
        if: steps.discover.outputs.has_deployments == 'true'
        id: apply
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "üöÄ Running terraform apply for multiple deployments..."
          echo "üîß Terraform directory: $TERRAFORM_DIR"
          
          # Use the deployment orchestrator to run applies
          set +e  # Don't exit on error - we want to show results even if some applies fail
          python3 ../controller/scripts/terraform-deployment-orchestrator.py apply \
            --deployments-json deployments.json \
            --output-summary apply-results.json \
            --debug
          
          apply_exit_code=$?
          set -e
          
          echo "üîç Apply exit code: $apply_exit_code"
          
          if [ -f apply-results.json ]; then
            total=$(jq -r '.total_deployments // 0' apply-results.json)
            successful=$(jq -r '.successful_applies // 0' apply-results.json)
            failed=$(jq -r '.failed_applies // 0' apply-results.json)
            
            echo "üìä Apply Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_applies=$successful" >> $GITHUB_OUTPUT
            echo "failed_applies=$failed" >> $GITHUB_OUTPUT
            
            if [ "$successful" -gt 0 ]; then
              echo "‚úÖ Applied $successful deployments successfully"
              if [ "$failed" -gt 0 ]; then
                echo "‚ö†Ô∏è $failed deployments failed"
                exit 1
              fi
            else
              echo "‚ùå No successful applies"
              exit 1
            fi
          else
            echo "‚ùå No apply-results.json found"
            exit 1
          fi

      - name: üí¨ Post Apply Results to Original PR
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            
            let comment = `## üöÄ Terraform Apply Results\n\n`;
            comment += `**Merged PR**: [#${{ github.event.client_payload.pr_number }}](${{ github.event.client_payload.pr_url }})\n`;
            comment += `**Applied to**: \`main\` branch\n\n`;
            
            const total = '${{ steps.apply.outputs.total_deployments }}';
            const successful = '${{ steps.apply.outputs.successful_applies }}';
            const failed = '${{ steps.apply.outputs.failed_applies }}';
            
            if (total && total !== '0') {
              comment += `### üìä Apply Summary\n`;
              comment += `| Metric | Count |\n`;
              comment += `|--------|-------|\n`;
              comment += `| üìã Total Deployments | ${total} |\n`;
              comment += `| ‚úÖ Successful Applies | ${successful} |\n`;
              comment += `| ‚ùå Failed Applies | ${failed} |\n\n`;
              
              // Add detailed results if available
              try {
                const applyResults = fs.readFileSync('source-repo/apply-results.json', 'utf8');
                const results = JSON.parse(applyResults);
                
                if (results.applies && results.applies.length > 0) {
                  comment += `### üìã Deployment Details\n`;
                  comment += `| Deployment | Status | Message |\n`;
                  comment += `|------------|--------|----------|\n`;
                  
                  results.applies.forEach(apply => {
                    const status = apply.status === 'success' ? '‚úÖ' : '‚ùå';
                    const message = apply.message || 'N/A';
                    comment += `| ${apply.deployment} | ${status} | ${message.substring(0, 50)} |\n`;
                  });
                  comment += `\n`;
                }
              } catch (e) {
                console.log('Could not read apply results:', e.message);
              }
              
              if (failed === '0') {
                comment += `\n‚úÖ **All deployments applied successfully!**\n`;
              } else {
                comment += `\n‚ö†Ô∏è **Some deployments failed - check logs for details**\n`;
              }
            } else {
              comment += `‚ÑπÔ∏è No deployments were applied\n`;
            }
            
            comment += `\n---\n`;
            comment += `ü§ñ *Centralized Controller - Apply* | `;
            comment += `[View Run](https://github.com/Terraform-centilazed-pipline/centerlized-pipline-/actions/runs/${{ github.run_id }})`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: ${{ github.event.client_payload.pr_number }},
              body: comment
            });

      - name: üì¶ Upload Apply Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-apply-results
          path: |
            source-repo/deployments.json
            source-repo/apply-results.json
            source-repo/logs/
            source-repo/*.log
