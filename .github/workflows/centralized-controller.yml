# =============================================================================
# CENTRALIZED TERRAFORM CONTROLLER - The Real Deal!
# =============================================================================
# This workflow runs in the CENTRALIZED repo
# It listens for events from dev repos and does ALL the work
# Uses centralized main.tf, scripts, policies - dev repos just trigger it
# =============================================================================

name: Centralized Controller

on:
  repository_dispatch:
    types: [terraform_pr, terraform_apply]

permissions:
  id-token: write
  contents: read
  actions: read

env:
  TERRAFORM_VERSION: '1.11.0'
  OPA_VERSION: '0.59.0'
  AWS_REGION: 'us-east-1'

jobs:
  terraform-controller:
    name: ğŸ¯ Terraform Controller
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“‹ Event Details
        run: |
          echo "ğŸ”” Repository Dispatch Event Received"
          echo "Source Repo: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}"
          echo "PR Number: ${{ github.event.client_payload.pr_number }}"
          echo "Action: ${{ github.event.client_payload.action }}"
          if [[ "${{ github.event.client_payload.action }}" == "apply" ]]; then
            echo "ğŸš€ APPLY MODE - Running terraform apply"
            echo "PR Head: ${{ github.event.client_payload.pr_head_ref }}"
            echo "PR SHA: ${{ github.event.client_payload.pr_head_sha }}"
            echo "Merged SHA: ${{ github.event.client_payload.merge_commit_sha }}"
          else
            echo "ğŸ” PLAN MODE - Running terraform plan and validation"
            echo "PR Head: ${{ github.event.client_payload.pr_head_ref }}"
            echo "PR SHA: ${{ github.event.client_payload.pr_head_sha }}"
          fi

      - name: Generate GitHub App Token
        id: app-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GT_APP_ID }}
          private_key: ${{ secrets.GT_APP_PRIVATE_KEY }}

      - name: Checkout Centralized Controller Repo
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/centerlized-pipline-
          path: controller
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout Source Dev Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}
          ref: ${{ github.event.client_payload.action == 'apply' && 'main' || github.event.client_payload.pr_head_ref }}
          path: source-repo
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout OPA Policies
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/opa-poclies
          path: opa-policies
          token: ${{ steps.app-token.outputs.token }}

      - name: ğŸ” Debug OPA Policies Structure
        run: |
          echo "ğŸ” === OPA POLICIES DEBUG ==="
          echo "ğŸ“ Root opa-policies directory:"
          ls -la opa-policies/ || echo "âŒ opa-policies directory not found"
          echo ""
          
          echo "ğŸ“‚ Looking for terraform/ directory:"
          if [ -d "opa-policies/terraform" ]; then
            echo "âœ… terraform/ directory found"
            ls -la opa-policies/terraform/
          else
            echo "âŒ terraform/ directory not found"
            echo "ğŸ“‹ Available directories in opa-policies/:"
            find opa-policies/ -type d -maxdepth 2 | head -10
          fi
          echo ""
          
          echo "ğŸ” Looking for .rego files:"
          find opa-policies/ -name "*.rego" -type f | head -10
          echo ""
          
          echo "ğŸ“‹ All files in opa-policies (first 20):"
          find opa-policies/ -type f | head -20

      # Note: tf-module checkout removed - Terraform fetches modules from GitHub automatically
      # Module sources now use: git::https://github.com/Terraform-centilazed-pipline/tf-module.git//Module/<NAME>

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN}}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-controller

      - name: ğŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: ğŸ”§ Setup OPA
        run: |
          echo "ğŸ“¦ Installing OPA ${{ env.OPA_VERSION }}..."
          curl -L -o opa https://openpolicyagent.org/downloads/v${{ env.OPA_VERSION }}/opa_linux_amd64_static
          chmod +x opa
          sudo mv opa /usr/local/bin/
          opa version

      - name: Configure Git Authentication for Terraform Modules
        run: |
          echo "ğŸ”§ Configuring Git authentication for private Terraform modules..."
          git config --global url."https://oauth2:${{ steps.app-token.outputs.token }}@github.com".insteadOf "https://github.com"
          echo "âœ… Git authentication configured for Terraform module downloads"

      # ===== Get changed files from PR (skip for apply mode) =====
      - name: ğŸ” Get Changed Files
        if: github.event.client_payload.action != 'apply'
        id: changed-files
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              pull_number: ${{ github.event.client_payload.pr_number }}
            });
            
            const tfvarsFiles = files
              .filter(f => f.filename.match(/\.(tfvars|yaml|yml|json)$/))
              .filter(f => f.filename.startsWith('Accounts/') || f.filename.startsWith('configs/'))
              .map(f => f.filename);
            
            console.log('Changed files:', tfvarsFiles);
            core.setOutput('files', tfvarsFiles.join(' '));
            core.setOutput('count', tfvarsFiles.length);

      # ===== STEP 1: DISCOVER DEPLOYMENTS =====
      - name: ğŸ” Discover Deployments
        if: github.event.client_payload.action != 'apply' && steps.changed-files.outputs.count > 0
        id: discover
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "ğŸ” Running discovery for plan mode..."
          echo "Changed files: ${{ steps.changed-files.outputs.files }}"
          echo "Changed files count: ${{ steps.changed-files.outputs.count }}"
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --changed-files "${{ steps.changed-files.outputs.files }}" \
            --output-summary deployments.json \
            --debug
          
          total=$(jq -r '.total_deployments // 0' deployments.json)
          echo "total=$total" >> $GITHUB_OUTPUT
          
          if [ "$total" -gt 0 ]; then
            echo "âœ… Found $total deployments"
            echo "has_deployments=true" >> $GITHUB_OUTPUT
            
            # Extract first tfvars file for pre-validation
            first_tfvars=$(jq -r '.deployments[0].tfvars_file // empty' deployments.json)
            echo "first_tfvars=$first_tfvars" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ No deployments found"
            echo "has_deployments=false" >> $GITHUB_OUTPUT
          fi

      # ===== APPLY MODE: Discover from merged files =====
      - name: ğŸ” Discover Deployments (Apply Mode)
        if: github.event.client_payload.action == 'apply'
        id: discover-apply
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "ğŸ” Running discovery for apply mode..."
          echo "Apply mode - using changed files: ${{ github.event.client_payload.changed_files || github.event.client_payload.files }}"
          # For apply mode, get changed files from the merge commit
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --changed-files "${{ github.event.client_payload.changed_files || github.event.client_payload.files }}" \
            --output-summary deployments.json \
            --debug
          
          total=$(jq -r '.total_deployments // 0' deployments.json)
          echo "total=$total" >> $GITHUB_OUTPUT
          
          if [ "$total" -gt 0 ]; then
            echo "âœ… Found $total deployments for apply"
            echo "has_deployments=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ No deployments found for apply"
            echo "has_deployments=false" >> $GITHUB_OUTPUT
          fi

      # ===== STEP 2: PRE-DEPLOYMENT VALIDATION (BEFORE terraform plan) =====
      - name: ğŸ” Pre-Deployment Validation
        if: steps.discover.outputs.has_deployments == 'true'
        id: pre_validation
        working-directory: source-repo
        continue-on-error: true
        run: |
          echo "ğŸ” Running pre-deployment validation..."
          echo "ğŸ“„ Validating: ${{ steps.discover.outputs.first_tfvars }}"
          echo "ğŸ‘¤ PR Author: ${{ github.event.client_payload.pr_author }}"
          
          # Run pre-deployment validator
          set +e
          python3 ../controller/scripts/pre-deployment-validator.py \
            "${{ steps.discover.outputs.first_tfvars }}" \
            "${{ github.event.client_payload.pr_author }}"
          
          validation_exit=$?
          set -e
          
          if [ -f pre-validation-comment.md ]; then
            echo "validation_comment_exists=true" >> $GITHUB_OUTPUT
          fi
          
          if [ $validation_exit -eq 0 ]; then
            echo "âœ… Pre-deployment validation passed"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Pre-deployment validation failed"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi
          
          exit $validation_exit

      - name: ğŸ’¬ Post Pre-Validation Comment
        if: steps.pre_validation.outputs.validation_comment_exists == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('source-repo/pre-validation-comment.md', 'utf8');
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: ${{ github.event.client_payload.pr_number }},
              body: comment
            });

      - name: ğŸ›‘ Stop if Pre-Validation Failed
        if: steps.pre_validation.outputs.validation_passed == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = '${{ github.event.client_payload.source_owner }}';
            const repo = '${{ github.event.client_payload.source_repo }}';
            const pr_number = ${{ github.event.client_payload.pr_number }};
            
            // Get PR details for notifications
            const { data: prData } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pr_number
            });
            
            // Close the PR
            await github.rest.pulls.update({
              owner,
              repo,
              pull_number: pr_number,
              state: 'closed'
            });
            
            // Add detailed notification about pre-validation failure
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pr_number,
              body: `ğŸ›‘ **PR Closed: Pre-Deployment Validation Failed**\n\n` +
                    `âŒ Your PR failed pre-deployment validation checks\n\n` +
                    `**Common Issues**:\n` +
                    `- Incorrect file structure or naming\n` +
                    `- Missing required configuration\n` +
                    `- Invalid account or environment setup\n` +
                    `- Permissions or access issues\n\n` +
                    `**Next Steps**:\n` +
                    `1. Check the validation results in the workflow logs\n` +
                    `2. Fix the identified issues\n` +
                    `3. Create a new PR with corrected changes\n\n` +
                    `ğŸ”” **Author**: @${prData.user.login} - Please review and fix the validation issues\n\n` +
                    `---\n` +
                    `*Pre-deployment validation must pass before Terraform planning can begin.*`
            });
            
            // Send notification to reviewers/assignees if any
            try {
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: pr_number
              });
              
              const reviewers = [...new Set(reviews.map(review => review.user.login))];
              const assignees = prData.assignees.map(assignee => assignee.login);
              const allNotifyUsers = [...new Set([...reviewers, ...assignees])];
              
              if (allNotifyUsers.length > 0) {
                const mentions = allNotifyUsers.map(user => `@${user}`).join(' ');
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr_number,
                  body: `âš ï¸ **Team Notification: Pre-Validation Failure**\n\n` +
                        `${mentions}\n\n` +
                        `The PR by @${prData.user.login} has been closed due to pre-deployment validation failures. ` +
                        `Please review the requirements and assist with fixing the issues if needed.\n\n` +
                        `*Automated notification from Centralized Terraform Controller*`
                });
              }
            } catch (error) {
              console.log('âš ï¸ Could not send team notifications for pre-validation failure:', error.message);
            }
            
            // Cleanup feature branch after pre-validation failure
            try {
              const branchName = prData.head.ref;
              const protectedBranches = ['main', 'master', 'develop', 'development', 'staging', 'production'];
              
              if (!protectedBranches.includes(branchName)) {
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: `heads/${branchName}`
                });
                
                console.log(`âœ… Deleted feature branch: ${branchName} after pre-validation failure`);
                
                // Add cleanup notification
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr_number,
                  body: `ğŸ§¹ **Branch Cleanup**: Feature branch \`${branchName}\` has been deleted. ` +
                        `Please create a new branch with the necessary fixes.`
                });
              } else {
                console.log(`âš ï¸ Skipped deletion of protected branch: ${branchName}`);
              }
            } catch (cleanupError) {
              console.log('âš ï¸ Could not cleanup feature branch after pre-validation failure:', cleanupError.message);
            }
            
            core.setFailed('âŒ Pre-deployment validation failed. PR closed.');

      # ===== STEP 3: TERRAFORM PLAN (Only runs if pre-validation passed) =====
      - name: ğŸ“‹ Terraform Plan
        if: steps.discover.outputs.has_deployments == 'true'
        id: plan
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "ğŸ“‹ Running terraform plan for multiple deployments..."
          echo "ğŸ”§ Terraform directory: $TERRAFORM_DIR"
          
          # Use the deployment orchestrator to run plans and create artifacts
          # This handles multiple deployments from different accounts properly
          set +e  # Don't exit on error - we want to show results even if some plans fail
          python3 ../controller/scripts/terraform-deployment-orchestrator-enhanced.py plan \
            --changed-files "${{ steps.changed-files.outputs.files }}" \
            --output-summary plan-results.json \
            --debug
          
          plan_exit_code=$?
          set -e  # Re-enable exit on error
          
          echo "ğŸ” Deployment manager exit code: $plan_exit_code"
          
          if [ -f plan-results.json ]; then
            total=$(jq -r '.summary.total // 0' plan-results.json)
            successful=$(jq -r '.summary.successful // 0' plan-results.json)
            failed=$(jq -r '.summary.failed // 0' plan-results.json)
            has_changes=$(jq -r 'if (.successful | length > 0) and ([.successful[] | select(.has_changes == true)] | length > 0) then "true" else "false" end' plan-results.json)
            
            echo "ğŸ“Š Plan Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_plans=$successful" >> $GITHUB_OUTPUT
            echo "failed_plans=$failed" >> $GITHUB_OUTPUT
            echo "has_changes=$has_changes" >> $GITHUB_OUTPUT
            
            # Prepare all plans for OPA validation
            if [ -d "terraform-json" ] && [ "$successful" -gt 0 ]; then
              mkdir -p canonical-plan
              json_files=(terraform-json/*.json)
              if [ -e "${json_files[0]}" ]; then
                echo "âœ… Found ${#json_files[@]} JSON plans for OPA validation"
                # Copy all JSON files to canonical-plan directory for multi-plan validation
                cp terraform-json/*.json canonical-plan/
                echo "opa_plan_ready=true" >> $GITHUB_OUTPUT
                echo "total_plans=${#json_files[@]}" >> $GITHUB_OUTPUT
              else
                echo "âš ï¸ No JSON plans found for OPA validation"
                echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
                echo "total_plans=0" >> $GITHUB_OUTPUT
              fi
            else
              echo "âš ï¸ No successful plans for OPA validation"
              echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
              echo "total_plans=0" >> $GITHUB_OUTPUT
            fi
            
            # Continue workflow even if some plans failed
            if [ "$successful" -gt 0 ]; then
              echo "âœ… Continuing workflow with $successful successful plans"
              exit 0
            else
              echo "âŒ No plans were successful"
              echo ""
              echo "ğŸ” Showing error details from plan-results.json:"
              if [ -f plan-results.json ]; then
                jq '.' plan-results.json || cat plan-results.json
              fi
              exit 1
            fi
          else
            echo "âŒ No plan-results.json found"
            exit 1
          fi

      # ===== STEP 4: OPA VALIDATION =====
      - name: ğŸ›¡ï¸ OPA Validation
        if: steps.plan.outputs.opa_plan_ready == 'true'
        id: opa
        working-directory: source-repo
        run: |
          echo "ğŸ›¡ï¸ Running OPA validation using Python validator..."
          echo "ğŸ“ Using OPA policies from: ../opa-policies/"
          echo "ğŸ“ Using plan files from: canonical-plan/"
          
          # Run the Python OPA validator script
          set +e  # Don't exit on error - we want to capture the results
          python3 ../controller/scripts/opa-validator.py \
            --opa-policies ../opa-policies \
            --plans-dir canonical-plan \
            --output opa-results.json \
            --debug
          
          validation_exit_code=$?
          set -e  # Re-enable exit on error
          
          echo "ğŸ” OPA validation exit code: $validation_exit_code"
          
          # Parse results from the JSON output
          if [ -f "opa-results.json" ]; then
            total_violations=$(jq -r '.summary.total_violations // 0' opa-results.json)
            critical_violations=$(jq -r '.summary.critical_violations // 0' opa-results.json)
            high_violations=$(jq -r '.summary.high_violations // 0' opa-results.json)
            medium_violations=$(jq -r '.summary.medium_violations // 0' opa-results.json)
            low_violations=$(jq -r '.summary.low_violations // 0' opa-results.json)
            services_detected=$(jq -r '.summary.services_detected // []' opa-results.json | jq -r 'join(",")')
            plans_validated=$(jq -r '.summary.plans_validated // 0' opa-results.json)
            
            echo "ğŸ“Š OPA Validation Summary:"
            echo "   Plans validated: $plans_validated"
            echo "   Total violations: $total_violations"
            echo "   Critical: $critical_violations"
            echo "   High: $high_violations"
            echo "   Medium: $medium_violations"
            echo "   Low: $low_violations"
            echo "   Services detected: $services_detected"
            
            # Set workflow outputs
            echo "total_violations=$total_violations" >> $GITHUB_OUTPUT
            echo "critical_violations=$critical_violations" >> $GITHUB_OUTPUT
            echo "high_violations=$high_violations" >> $GITHUB_OUTPUT
            echo "medium_violations=$medium_violations" >> $GITHUB_OUTPUT
            echo "low_violations=$low_violations" >> $GITHUB_OUTPUT
            echo "services_detected=$services_detected" >> $GITHUB_OUTPUT
            echo "plans_validated=$plans_validated" >> $GITHUB_OUTPUT
            
            # Determine validation status
            if [ "$validation_exit_code" -eq 0 ]; then
              echo "validation_status=passed" >> $GITHUB_OUTPUT
              echo ""
              echo "âœ… All policies passed - deployment authorized!"
            elif [ "$validation_exit_code" -eq 1 ]; then
              echo "validation_status=failed" >> $GITHUB_OUTPUT
              echo ""
              echo "âŒ Validation failed: $total_violations violations found"
              
              # Show violations details if any
              if [ "$total_violations" -gt 0 ]; then
                echo ""
                echo "ğŸ“‹ Violation Details:"
                jq -r '.violations[] | "  - [\(.severity)] \(.message)"' opa-results.json || true
              fi
            else
              echo "validation_status=error" >> $GITHUB_OUTPUT
              echo ""
              echo "âŒ OPA validation error - unexpected exit code: $validation_exit_code"
            fi
          else
            echo "âŒ No OPA results file found"
            echo "validation_status=error" >> $GITHUB_OUTPUT
            echo "total_violations=0" >> $GITHUB_OUTPUT
            echo "critical_violations=0" >> $GITHUB_OUTPUT
            echo "high_violations=0" >> $GITHUB_OUTPUT
            echo "medium_violations=0" >> $GITHUB_OUTPUT
            echo "low_violations=0" >> $GITHUB_OUTPUT
            echo "services_detected=" >> $GITHUB_OUTPUT
            echo "plans_validated=0" >> $GITHUB_OUTPUT
          fi
          
          # Exit with appropriate code for workflow control
          exit $validation_exit_code
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object" and .severity == "high")] | length' 2>/dev/null || echo "0")
             
          medium_violations=$(echo "$violations_json" | jq -r '
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object" and .severity == "medium")] | length' 2>/dev/null || echo "0")
             
          low_violations=$(echo "$violations_json" | jq -r '
            [.result[0].expressions[0].value // {} | 
             if type == "object" then keys[] else empty end |
             try fromjson catch empty |
             select(type == "object" and .severity == "low")] | length' 2>/dev/null || echo "0")
          
          # Ensure variables are numeric (default to 0 if empty, remove any whitespace/newlines)
          total_violations=$(echo "${total_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          critical_violations=$(echo "${critical_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          high_violations=$(echo "${high_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          medium_violations=$(echo "${medium_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          low_violations=$(echo "${low_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          
          echo ""
          echo "ğŸ“Š Validation Results:"
          echo "   Total violations: $total_violations"
          echo "   ğŸ”´ Critical: $critical_violations"
          echo "   ğŸŸ  High: $high_violations"
          echo "   ğŸŸ¡ Medium: $medium_violations"
          echo "   ğŸŸ¢ Low: $low_violations"
          
          # Set outputs
          echo "total_violations=$total_violations" >> $GITHUB_OUTPUT
          echo "critical_violations=$critical_violations" >> $GITHUB_OUTPUT
          echo "high_violations=$high_violations" >> $GITHUB_OUTPUT
          echo "medium_violations=$medium_violations" >> $GITHUB_OUTPUT
          echo "low_violations=$low_violations" >> $GITHUB_OUTPUT
          echo "services_detected=$services_detected" >> $GITHUB_OUTPUT
          
          if [ "$total_violations" -eq 0 ]; then
            echo "validation_status=passed" >> $GITHUB_OUTPUT
            echo ""
            echo "âœ… All policies passed - deployment authorized!"
          else
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            echo ""
            echo "âŒ Validation failed: $total_violations violations found"
            echo ""
            echo "ğŸ“‹ Violation Details:"
            cat opa-result.txt
          fi

      # ===== DEBUG: Show Actual Plan JSON Structure =====
      - name: ğŸ” Debug Actual Plan JSON Structure  
        if: steps.plan.outputs.opa_plan_ready == 'true'
        working-directory: source-repo
        run: |
          echo "ğŸ” === ACTUAL PLAN JSON STRUCTURE DEBUG ==="
          echo ""
          echo "ğŸ“‚ Available JSON plans:"
          ls -la canonical-plan/*.json || echo "No JSON files found"
          echo ""
          
          for json_file in canonical-plan/*.json; do
            if [ ! -f "$json_file" ]; then
              continue
            fi
            
            plan_name=$(basename "$json_file" .json)
            echo "ğŸ“„ === PLAN: $plan_name ==="
            echo "ğŸ“Š File size: $(wc -c < "$json_file") bytes"
            echo ""
            
            echo "ğŸ” Top-level structure:"
            jq 'keys' "$json_file" 2>/dev/null || echo "Failed to parse JSON"
            echo ""
            
            echo "ğŸ” Resource changes summary:"
            echo "   Total resource changes: $(jq -r '.resource_changes | length' "$json_file" 2>/dev/null || echo "0")"
            echo "   Resource types:"
            jq -r '.resource_changes[]?.type' "$json_file" 2>/dev/null | sort | uniq -c || echo "   No types found"
            echo ""
            
            echo "ğŸ” First few resource changes (structure):"
            jq -r '.resource_changes[0:2] | .[] | {type: .type, actions: .change.actions, address: .address, after_sample: .change.after}' "$json_file" 2>/dev/null || echo "   No resource changes found"
            echo ""
            
            echo "ğŸ” S3-related resources:"
            jq -r '.resource_changes[] | select(.type | contains("s3")) | {type: .type, address: .address, actions: .change.actions, tags: .change.after.tags}' "$json_file" 2>/dev/null || echo "   No S3 resources found"
            echo ""
            
            # Show first 50 lines of the actual JSON for manual inspection
            echo "ğŸ” First 50 lines of actual JSON content:"
            echo '```json'
            head -50 "$json_file"
            echo ""
            echo "... (truncated)"
            echo '```'
            echo ""
            
            # Show specific sections
            echo "ğŸ” Planned values (if present):"
            jq -r '.planned_values.root_module.resources[0:2] | .[] | {type: .type, address: .address}' "$json_file" 2>/dev/null || echo "   No planned values found"
            echo ""
            
            echo "ğŸ” Configuration (if present):"
            jq -r '.configuration.root_module.resources[0:2] | .[] | {type: .type, address: .address}' "$json_file" 2>/dev/null || echo "   No configuration found"
            echo ""
            
            echo "=====================================\n"
          done
          
          echo "ğŸ’¡ This debug output shows the actual structure of your Terraform plan JSON files."
          echo "   Compare this with your test files to ensure they match the expected format."

      # ===== DEBUG: Check OPA Syntax Errors =====
      - name: ğŸ” Debug OPA Syntax Errors
        if: steps.plan.outputs.opa_plan_ready == 'true'
        working-directory: source-repo
        run: |
          echo "ğŸ” === OPA SYNTAX ERROR DEBUG ==="
          echo ""
          echo "ğŸ“ OPA policies directory structure:"
          find ../opa-policies/ -name "*.rego" | head -10
          echo ""
          
          echo "ğŸ” Testing OPA syntax on each policy file:"
          for rego_file in $(find ../opa-policies/ -name "*.rego"); do
            echo "  Testing: $rego_file"
            opa fmt "$rego_file" --diff 2>&1 || echo "    âŒ Syntax error in $rego_file"
          done
          echo ""
          
          echo "ğŸ” Full OPA error output when loading policies:"
          opa eval -d ../opa-policies/ "data.terraform.main" --format json 2>&1 || true
          echo ""
          
          echo "ğŸ” Testing individual policy directories:"
          for dir in $(find ../opa-policies/ -type d -name "*"); do
            if [ -f "$dir"/*.rego ]; then
              echo "  Testing directory: $dir"
              opa eval -d "$dir" "data" --format json 2>&1 | head -5 || true
              echo ""
            fi
          done
          
          echo "ğŸ” Checking for import syntax compatibility:"
          grep -r "import rego.v1" ../opa-policies/ || echo "  No rego.v1 imports found"
          echo ""
          
          echo "ğŸ” OPA version being used:"
          opa version
          total_violations=$(echo "${total_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          critical_violations=$(echo "${critical_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          high_violations=$(echo "${high_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          medium_violations=$(echo "${medium_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          low_violations=$(echo "${low_violations:-0}" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
          
          echo ""
          echo "ğŸ“Š Validation Results:"
          echo "   Total violations: $total_violations"
          echo "   ğŸ”´ Critical: $critical_violations"
          echo "   ğŸŸ  High: $high_violations"
          echo "   ğŸŸ¡ Medium: $medium_violations"
          echo "   ğŸŸ¢ Low: $low_violations"
          
          # Set outputs
          echo "total_violations=$total_violations" >> $GITHUB_OUTPUT
          echo "critical_violations=$critical_violations" >> $GITHUB_OUTPUT
          echo "high_violations=$high_violations" >> $GITHUB_OUTPUT
          echo "medium_violations=$medium_violations" >> $GITHUB_OUTPUT
          echo "low_violations=$low_violations" >> $GITHUB_OUTPUT
          echo "services_detected=$services_detected" >> $GITHUB_OUTPUT
          
          if [ "$total_violations" -eq 0 ]; then
            echo "validation_status=passed" >> $GITHUB_OUTPUT
            echo ""
            echo "âœ… All policies passed - deployment authorized!"
          else
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            echo ""
            echo "âŒ Validation failed: $total_violations violations found"
            echo ""
            echo "ğŸ“‹ Violation Details:"
            cat opa-result.txt
          fi

      # ===== STEP 4: POST PR COMMENT =====
      - name: ğŸ’¬ Post PR Comment
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            
            // Determine overall status for visual feedback
            const validation = '${{ steps.opa.outputs.validation_status }}';
            const hasChanges = '${{ steps.plan.outputs.has_changes }}' === 'true';
            const planFailed = '${{ steps.plan.outputs.failed_plans }}' !== '0';
            
            const statusIcon = validation === 'passed' ? 'âœ…' : validation === 'failed' ? 'âŒ' : 'âš ï¸';
            const statusText = validation === 'passed' ? '**APPROVED**' : validation === 'failed' ? '**BLOCKED**' : '**PENDING**';
            const statusColor = validation === 'passed' ? 'ğŸŸ¢' : validation === 'failed' ? 'ğŸ”´' : 'ğŸŸ¡';
            
            let comment = `## ğŸš€ Centralized Terraform Controller Results\n\n`;
            
            // Status banner
            comment += `> ${statusIcon} **Overall Status**: ${statusColor} ${statusText}\n`;
            comment += `> ğŸ“¦ **Source**: \`${{ github.event.client_payload.source_repo }}\`\n`;
            comment += `> ğŸ”€ **PR**: [#${{ github.event.client_payload.pr_number }}](${{ github.event.client_payload.pr_url }}) (branch: \`${{ github.event.client_payload.pr_head_ref }}\`)\n`;
            comment += `> ğŸ”„ **Changes Detected**: ${hasChanges ? '**Yes**' : 'No'}\n`;
            comment += `\n`;
            comment += `---\n\n`;
            
            // Plan results
            const total = '${{ steps.plan.outputs.total_deployments }}';
            const successful = '${{ steps.plan.outputs.successful_plans }}';
            const failed = '${{ steps.plan.outputs.failed_plans }}';
            const planHasChanges = '${{ steps.plan.outputs.has_changes }}';
            
            if (total && total !== '0') {
              comment += `### ğŸ“Š Terraform Plan Summary\n\n`;
              comment += `| Metric | Value |\n`;
              comment += `|--------|-------|\n`;
              comment += `| ğŸ“‹ Total Deployments | **${total}** |\n`;
              comment += `| âœ… Successful Plans | **${successful}** |\n`;
              comment += `| âŒ Failed Plans | **${failed}** |\n`;
              comment += `| ğŸ”„ Has Changes | **${planHasChanges === 'true' ? 'Yes' : 'No'}** |\n\n`;
              
              // Add detailed plan results with DEEP resource analysis
              try {
                const planResults = fs.readFileSync('source-repo/plan-results.json', 'utf8');
                const results = JSON.parse(planResults);
                
                if (results.successful && results.successful.length > 0) {
                  comment += `### âœ… Successful Deployments\n\n`;
                  
                  results.successful.forEach(result => {
                    const dep = result.deployment;
                    const backendKey = result.backend_key || 'N/A';
                    const services = result.services ? result.services.join(', ') : 'N/A';
                    
                    comment += `<table>\n`;
                    comment += `<tr><td colspan="2">\n\n`;
                    comment += `#### ğŸ¯ ${dep.account_name} / ${dep.region} / ${dep.project}\n\n`;
                    comment += `</td></tr>\n`;
                    comment += `<tr><td><b>ğŸ”‘ Backend Key</b></td><td><code>${backendKey}</code></td></tr>\n`;
                    comment += `<tr><td><b>ğŸ—ï¸ Services</b></td><td>${services}</td></tr>\n`;
                    comment += `<tr><td><b>ğŸŒ Environment</b></td><td>${dep.environment || 'N/A'}</td></tr>\n`;
                    comment += `<tr><td><b>ğŸ“ Deployment Path</b></td><td><code>${dep.deployment_dir || 'N/A'}</code></td></tr>\n`;
                    comment += `</table>\n\n`;
                    
                    // DEEP Parse terraform output for resource changes
                    if (result.has_changes && result.output) {
                      const output = result.output;
                      
                      // Extract resource changes summary
                      const updateMatch = output.match(/(\d+) to add, (\d+) to change, (\d+) to destroy/);
                      if (updateMatch) {
                        const [_, toAdd, toChange, toDestroy] = updateMatch;
                        const totalChanges = parseInt(toAdd) + parseInt(toChange) + parseInt(toDestroy);
                        
                        comment += `\n**ğŸ“Š Change Summary** (${totalChanges} total operations):\n\n`;
                        comment += `<table>\n`;
                        if (toAdd !== '0') comment += `<tr><td>ğŸŸ¢ <b>Create</b></td><td align="right"><b>${toAdd}</b> resource(s)</td><td>New resources will be provisioned</td></tr>\n`;
                        if (toChange !== '0') comment += `<tr><td>ğŸŸ¡ <b>Update</b></td><td align="right"><b>${toChange}</b> resource(s)</td><td>Existing resources will be modified</td></tr>\n`;
                        if (toDestroy !== '0') comment += `<tr><td>ğŸ”´ <b>Destroy</b></td><td align="right"><b>${toDestroy}</b> resource(s)</td><td>âš ï¸ Resources will be deleted!</td></tr>\n`;
                        comment += `</table>\n\n`;
                      }
                      
                      // Extract and parse DETAILED resource information
                      const lines = output.split('\n');
                      const resourceChanges = [];
                      let currentResource = null;
                      let inResourceBlock = false;
                      
                      for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        
                        // Detect resource operations
                        if (line.match(/^\s*#\s+module\./)) {
                          if (currentResource) resourceChanges.push(currentResource);
                          
                          const resourceMatch = line.match(/^\s*#\s+(module\.[^\s]+)/);
                          if (resourceMatch) {
                            currentResource = {
                              name: resourceMatch[1],
                              action: line.includes('will be created') ? 'create' :
                                     line.includes('will be destroyed') ? 'destroy' :
                                     line.includes('must be replaced') ? 'replace' :
                                     line.includes('will be updated') ? 'update' : 'modify',
                              attributes: []
                            };
                            inResourceBlock = true;
                          }
                        }
                        
                        // Capture attribute changes
                        if (inResourceBlock && currentResource) {
                          // Detect additions (+)
                          if (line.match(/^\s*\+\s+/)) {
                            const attrMatch = line.match(/^\s*\+\s+([^\s=]+)\s*=\s*(.+)/);
                            if (attrMatch) {
                              currentResource.attributes.push({
                                type: 'add',
                                name: attrMatch[1],
                                value: attrMatch[2].replace(/^"(.*)"$/, '$1')
                              });
                            }
                          }
                          // Detect updates (~)
                          else if (line.match(/^\s*~\s+/)) {
                            const attrMatch = line.match(/^\s*~\s+([^\s=]+)\s*=\s*"?([^"]+)"?\s*->\s*"?([^"]+)"?/);
                            if (attrMatch) {
                              currentResource.attributes.push({
                                type: 'update',
                                name: attrMatch[1],
                                oldValue: attrMatch[2],
                                newValue: attrMatch[3]
                              });
                            }
                          }
                          // Detect deletions (-)
                          else if (line.match(/^\s*-\s+/)) {
                            const attrMatch = line.match(/^\s*-\s+([^\s=]+)\s*=\s*(.+)/);
                            if (attrMatch) {
                              currentResource.attributes.push({
                                type: 'delete',
                                name: attrMatch[1],
                                value: attrMatch[2].replace(/^"(.*)"$/, '$1')
                              });
                            }
                          }
                          
                          // End of resource block
                          if (line.match(/^\s*}\s*$/) && !line.includes('->')) {
                            inResourceBlock = false;
                          }
                        }
                      }
                      if (currentResource) resourceChanges.push(currentResource);
                      
                      // Display DETAILED resource changes
                      if (resourceChanges.length > 0) {
                        comment += `<details>\n<summary>ğŸ” <b>Detailed Resource Analysis</b> (${resourceChanges.length} resources with ${resourceChanges.reduce((sum, r) => sum + r.attributes.length, 0)} attribute changes)</summary>\n\n`;
                        
                        resourceChanges.slice(0, 15).forEach((resource, idx) => {
                          const actionIcon = resource.action === 'create' ? 'ğŸŸ¢ â•' :
                                           resource.action === 'destroy' ? 'ğŸ”´ ğŸ—‘ï¸' :
                                           resource.action === 'replace' ? 'ğŸŸ  ğŸ”„' :
                                           'ğŸŸ¡ ğŸ“';
                          const actionText = resource.action.toUpperCase();
                          
                          comment += `\n**${idx + 1}. ${actionIcon} ${actionText}** \`${resource.name}\`\n\n`;
                          
                          if (resource.attributes.length > 0) {
                            comment += `<table>\n`;
                            comment += `<tr><th>Action</th><th>Attribute</th><th>Change Details</th></tr>\n`;
                            
                            resource.attributes.slice(0, 10).forEach(attr => {
                              if (attr.type === 'add') {
                                comment += `<tr><td>ğŸŸ¢ â•</td><td><code>${attr.name}</code></td><td><code>${attr.value}</code></td></tr>\n`;
                              } else if (attr.type === 'update') {
                                comment += `<tr><td>ğŸŸ¡ ğŸ“</td><td><code>${attr.name}</code></td><td><code>${attr.oldValue}</code> â†’ <code>${attr.newValue}</code></td></tr>\n`;
                              } else if (attr.type === 'delete') {
                                comment += `<tr><td>ğŸ”´ â–</td><td><code>${attr.name}</code></td><td><s><code>${attr.value}</code></s></td></tr>\n`;
                              }
                            });
                            
                            if (resource.attributes.length > 10) {
                              comment += `<tr><td colspan="3"><i>... and ${resource.attributes.length - 10} more attribute(s)</i></td></tr>\n`;
                            }
                            
                            comment += `</table>\n`;
                          }
                        });
                        
                        if (resourceChanges.length > 15) {
                          comment += `\n**ğŸ“‹ Additional Resources**: ${resourceChanges.length - 15} more resource(s) affected (see full plan output for details)\n`;
                        }
                        
                        comment += `\n</details>\n\n`;
                      }
                    } else if (!result.has_changes) {
                      comment += `\nâœ¨ **No changes detected** - Infrastructure matches desired state perfectly!\n\n`;
                      comment += `> ğŸ’š All resources are up-to-date. No action required.\n\n`;
                    }
                    
                    comment += `\n---\n\n`;
                  });
                }
                
                if (results.failed && results.failed.length > 0) {
                  comment += `### âŒ Failed Deployments\n\n`;
                  
                  results.failed.forEach(result => {
                    const dep = result.deployment;
                    const error = result.error || 'Unknown error';
                    
                    comment += `#### ğŸš¨ ${dep.account_name}/${dep.region}/${dep.project}\n\n`;
                    comment += `**Error**: \`${error}\`\n\n`;
                    
                    if (result.error_detail) {
                      comment += `<details>\n<summary>ğŸ” Error Details</summary>\n\n`;
                      comment += `\`\`\`\n${result.error_detail.substring(0, 1000)}\n\`\`\`\n`;
                      if (result.error_detail.length > 1000) {
                        comment += `\n... (truncated)\n`;
                      }
                      comment += `</details>\n\n`;
                    }
                    
                    comment += `---\n\n`;
                  });
                }
              } catch (e) {
                console.log('Could not parse plan results:', e.message);
                comment += `âš ï¸ Plan results available but couldn't parse details\n\n`;
              }
            } else {
              comment += `### ğŸ“‹ Terraform Plan\n\n`;
              comment += `â„¹ï¸ No deployments found or no changes detected\n\n`;
            }
            
            // OPA results - using validation variable already declared at top
            const violations = '${{ steps.opa.outputs.total_violations }}';
            const plansValidated = '${{ steps.opa.outputs.plans_validated }}';
            const criticalViolations = '${{ steps.opa.outputs.critical_violations }}';
            const highViolations = '${{ steps.opa.outputs.high_violations }}';
            const mediumViolations = '${{ steps.opa.outputs.medium_violations }}';
            const lowViolations = '${{ steps.opa.outputs.low_violations }}';
            
            comment += `### ğŸ›¡ï¸ OPA Policy Validation\n\n`;
            if (validation === 'passed') {
              comment += `âœ… **Status**: **PASSED** - All policies compliant!\n\n`;
              comment += `| Metric | Value |\n`;
              comment += `|--------|-------|\n`;
              comment += `| ğŸ“‹ Plans Validated | **${plansValidated || 1}** |\n`;
              comment += `| âœ… Policy Compliance | **100%** |\n`;
              comment += `| ğŸ”’ Security Status | **Approved** |\n\n`;
              comment += `âœ¨ All ${plansValidated || 1} plan(s) meet security and compliance requirements.\n\n`;
            } else if (validation === 'failed') {
              comment += `âŒ **Status**: **FAILED** - Policy violations detected\n\n`;
              
              const totalViolations = parseInt(violations || 0);
              const critical = parseInt(criticalViolations || 0);
              const high = parseInt(highViolations || 0);
              const medium = parseInt(mediumViolations || 0);
              const low = parseInt(lowViolations || 0);
              
              comment += `**âš ï¸ Violations Summary** (${totalViolations} total across ${plansValidated || 1} plan(s)):\n\n`;
              comment += `| Severity | Count | Status |\n`;
              comment += `|----------|-------|--------|\n`;
              if (critical > 0) comment += `| ğŸ”´ **Critical** | **${critical}** | â›” Must Fix |\n`;
              if (high > 0) comment += `| ğŸŸ  **High** | **${high}** | âš ï¸ Priority |\n`;
              if (medium > 0) comment += `| ğŸŸ¡ **Medium** | **${medium}** | âš¡ Review |\n`;
              if (low > 0) comment += `| ğŸ”µ **Low** | **${low}** | â„¹ï¸ Optional |\n`;
              comment += `\n`;
              
              try {
                const opaResults = fs.readFileSync('source-repo/opa-detailed-results.md', 'utf8');
                comment += `<details>\n<summary>ğŸ” Detailed Validation Results (click to expand)</summary>\n\n`;
                comment += opaResults;
                comment += `\n</details>\n\n`;
              } catch (e) {
                console.log('No detailed OPA results found, trying legacy format...');
                try {
                  const opaResult = fs.readFileSync('source-repo/opa-result.txt', 'utf8');
                  comment += `<details>\n<summary>ğŸ” Detailed Validation Results (click to expand)</summary>\n\n`;
                  comment += `\`\`\`\n${opaResult}\n\`\`\`\n`;
                  comment += `\n</details>\n\n`;
                } catch (e2) {
                  console.log('No OPA results file found');
                }
              }
              
              comment += `> **ğŸ”´ Action Required**: Please address the violations above before merging.\n`;
              if (critical > 0 || high > 0) {
                comment += `> **âš ï¸ Blocking Issues**: ${critical + high} critical/high severity violation(s) must be fixed.\n`;
              }
              comment += `\n`;
            } else if ('${{ steps.plan.outputs.opa_plan_ready }}' === 'false') {
              comment += `âš ï¸ **Status**: SKIPPED - No successful plans available for validation\n\n`;
            }
            
            // Add helpful footer with next steps
            comment += `\n---\n\n`;
            comment += `### ğŸ“š Resources & Next Steps\n\n`;
            
            if (validation === 'passed') {
              comment += `âœ… **Your deployment is approved!**\n\n`;
              comment += `**What happens next?**\n`;
              comment += `1. âœ… This PR will be **automatically merged**\n`;
              comment += `2. ğŸš€ Terraform apply will execute automatically\n`;
              comment += `3. ğŸ“§ You'll receive notifications about deployment progress\n\n`;
            } else if (validation === 'failed') {
              comment += `âŒ **Action required to proceed:**\n\n`;
              comment += `1. ğŸ“ Review the policy violations listed above\n`;
              comment += `2. ğŸ”§ Update your Terraform code to fix the issues\n`;
              comment += `3. ğŸ”„ Push your changes to trigger re-validation\n`;
              comment += `4. âœ… Once all policies pass, PR will auto-merge\n\n`;
              comment += `**Need help?** Check [OPA Policy Documentation](https://github.com/Terraform-centilazed-pipline/opa-poclies)\n\n`;
            }
            
            comment += `<details>\n<summary>ğŸ”— Useful Links</summary>\n\n`;
            comment += `- ğŸ¤– [View Workflow Run](https://github.com/Terraform-centilazed-pipline/centerlized-pipline-/actions/runs/${{ github.run_id }})\n`;
            comment += `- ğŸ“‹ [OPA Policy Repository](https://github.com/Terraform-centilazed-pipline/opa-poclies)\n`;
            comment += `- ğŸ—ï¸ [Terraform Modules](https://github.com/Terraform-centilazed-pipline/tf-module)\n`;
            comment += `- ğŸ“– [Deployment Guide](https://github.com/Terraform-centilazed-pipline/centerlized-pipline-/blob/main/README.md)\n`;
            comment += `</details>\n\n`;
            
            comment += `---\n`;
            comment += `ğŸ¤– *Automated by Centralized Terraform Controller* | `;
            comment += `â° *Generated at ${new Date().toISOString()}*`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: ${{ github.event.client_payload.pr_number }},
              body: comment
            });

      # ===== STEP 5: AUTO-MERGE OR CLOSE PR =====
      - name: ğŸ”€ Handle PR - Auto-merge if OPA Passed
        if: steps.opa.outputs.validation_status != ''
        id: merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const validation = '${{ steps.opa.outputs.validation_status }}';
            const owner = '${{ github.event.client_payload.source_owner }}';
            const repo = '${{ github.event.client_payload.source_repo }}';
            const pr_number = ${{ github.event.client_payload.pr_number }};
            
            if (validation === 'passed') {
              console.log('âœ… OPA passed - auto-merging PR');
              
              try {
                const { data: mergeResult } = await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr_number,
                  merge_method: 'squash',
                  commit_title: '[Terraform] Auto-approved: OPA validation passed',
                  commit_message: 'Automatically merged after successful OPA policy validation.\n\nAll security policies passed. Terraform changes approved for deployment.'
                });
                
                console.log('âœ… PR merged successfully');
                console.log('Merge SHA:', mergeResult.sha);
                
                // Set output for triggering apply job
                core.setOutput('merged', 'true');
                core.setOutput('merge_sha', mergeResult.sha);
                
                // Get PR details for notifications
                const { data: prData } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pr_number
                });
                
                // Add success comment with team notifications
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr_number,
                  body: `âœ… **PR Auto-Approved & Merged!**\n\n` +
                        `ğŸ›¡ï¸ OPA validation passed - all security policies compliant\n` +
                        `ğŸ¯ Services validated: ${{ steps.opa.outputs.services_detected || 'All services' }}\n` +
                        `ğŸ”€ Changes have been merged to \`main\`\n` +
                        `ğŸš€ Terraform apply will begin automatically...\n\n` +
                        `**Merge SHA**: \`${mergeResult.sha}\`\n\n` +
                        `ğŸ”” **Team Notification**: @${prData.user.login} - Your changes have been automatically approved and deployed!`
                });
                
                // Send additional success notification to stakeholders
                try {
                  const { data: reviews } = await github.rest.pulls.listReviews({
                    owner,
                    repo,
                    pull_number: pr_number
                  });
                  
                  const reviewers = [...new Set(reviews.map(review => review.user.login))];
                  const assignees = prData.assignees.map(assignee => assignee.login);
                  const allNotifyUsers = [...new Set([prData.user.login, ...reviewers, ...assignees])];
                  
                  if (allNotifyUsers.length > 1) { // Only send if there are multiple stakeholders
                    const mentions = allNotifyUsers.map(user => `@${user}`).join(' ');
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: pr_number,
                      body: `ğŸ‰ **Deployment Success Notification**\n\n` +
                            `${mentions}\n\n` +
                            `âœ… Security policies passed\n` +
                            `ğŸš€ Changes automatically merged and deployment initiated\n` +
                            `ğŸ“Š Validation results: ${{ steps.opa.outputs.total_violations || 0 }} violations found\n\n` +
                            `*Automated notification from Centralized Terraform Controller*`
                    });
                  }
                } catch (error) {
                  console.log('âš ï¸ Could not send team notifications:', error.message);
                }
                
              } catch (error) {
                console.log('âŒ Could not merge:', error.message);
                core.setOutput('merged', 'false');
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr_number,
                  body: `âš ï¸ **Auto-merge Failed**\n\nOPA validation passed, but automatic merge failed.\n\nError: ${error.message}\n\nPlease merge manually.`
                });
              }
            } else if (validation === 'failed') {
              console.log('âŒ OPA failed - closing PR');
              
              core.setOutput('merged', 'false');
              
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr_number,
                state: 'closed'
              });
              
              // Try to include detailed violation information
              let detailedInfo = '';
              try {
                const fs = require('fs');
                const detailedResults = fs.readFileSync('source-repo/opa-detailed-results.md', 'utf8');
                detailedInfo = `\n<details>\n<summary>ğŸ“‹ Click to view detailed violation information</summary>\n\n${detailedResults}\n</details>\n\n`;
              } catch (e) {
                detailedInfo = `\nğŸ’¡ **Note**: Check the workflow logs for detailed violation information.\n\n`;
              }
              
              // Get PR details for notifications
              const { data: prData } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr_number
              });
              
              // Create main comment with violation details
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr_number,
                body: `âŒ **PR Closed: Policy Violations**\n\n` +
                      `ğŸ›¡ï¸ OPA validation failed with **${{ steps.opa.outputs.total_violations }} violations**\n\n` +
                      `**Severity Breakdown**:\n` +
                      `- ğŸ”´ Critical: ${{ steps.opa.outputs.critical_violations }}\n` +
                      `- ğŸŸ  High: ${{ steps.opa.outputs.high_violations }}\n` +
                      `- ğŸŸ¡ Medium: ${{ steps.opa.outputs.medium_violations }}\n` +
                      `- ğŸŸ¢ Low: ${{ steps.opa.outputs.low_violations }}\n\n` +
                      `**Services Validated**: ${{ steps.opa.outputs.services_detected || 'All' }}\n` +
                      detailedInfo +
                      `This PR has been automatically closed due to security policy violations.\n\n` +
                      `**Required Actions**:\n` +
                      `1. Review the detailed violation information above\n` +
                      `2. Fix all policy violations in your Terraform configuration\n` +
                      `3. Ensure all required tags are present (especially \`ManagedBy\`)\n` +
                      `4. Create a new PR with corrected changes\n\n` +
                      `---\n` +
                      `*Security policies must pass before changes can be merged.*\n\n` +
                      `ğŸ”” **Notifications sent to**: @${prData.user.login}, reviewers, and watchers`
              });
              
              // Send additional notifications to key stakeholders
              try {
                // Get PR reviewers and assignees
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner,
                  repo,
                  pull_number: pr_number
                });
                
                const reviewers = [...new Set(reviews.map(review => review.user.login))];
                const assignees = prData.assignees.map(assignee => assignee.login);
                const allNotifyUsers = [...new Set([prData.user.login, ...reviewers, ...assignees])];
                
                // Create targeted notification comment
                if (allNotifyUsers.length > 0) {
                  const mentions = allNotifyUsers.map(user => `@${user}`).join(' ');
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pr_number,
                    body: `ğŸš¨ **Security Policy Violation Alert**\n\n` +
                          `${mentions}\n\n` +
                          `This PR has been closed due to Terraform security policy violations. ` +
                          `Please review the violations above and create a new PR with the necessary fixes.\n\n` +
                          `**Critical Actions Required**:\n` +
                          `- [ ] Review policy violations\n` +
                          `- [ ] Fix missing or incorrect tags\n` +
                          `- [ ] Validate changes locally\n` +
                          `- [ ] Create new PR with fixes\n\n` +
                          `*This is an automated security notification from the Centralized Terraform Controller.*`
                  });
                }
              } catch (error) {
                console.log('âš ï¸ Could not send targeted notifications:', error.message);
              }
              
              console.log('âŒ PR closed due to policy violations');
              
              // Cleanup feature branch after policy violation closure
              try {
                const branchName = prData.head.ref;
                const protectedBranches = ['main', 'master', 'develop', 'development', 'staging', 'production'];
                
                if (!protectedBranches.includes(branchName)) {
                  await github.rest.git.deleteRef({
                    owner,
                    repo,
                    ref: `heads/${branchName}`
                  });
                  
                  console.log(`âœ… Deleted feature branch: ${branchName} after policy violation`);
                  
                  // Add cleanup notification
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pr_number,
                    body: `ğŸ§¹ **Branch Cleanup**: Feature branch \`${branchName}\` has been automatically deleted. ` +
                          `Create a new branch when you're ready to submit fixes.`
                  });
                } else {
                  console.log(`âš ï¸ Skipped deletion of protected branch: ${branchName}`);
                }
              } catch (cleanupError) {
                console.log('âš ï¸ Could not cleanup feature branch:', cleanupError.message);
              }
            }

      # ===== STEP 6: TRIGGER TERRAFORM APPLY (after successful merge) =====
      - name: ğŸš€ Trigger Terraform Apply
        if: steps.merge.outputs.merged == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            console.log('ğŸš€ Triggering Terraform Apply workflow...');
            
            // Dispatch apply event to this same workflow
            await github.rest.repos.createDispatchEvent({
              owner: 'Terraform-centilazed-pipline',
              repo: 'centerlized-pipline-',
              event_type: 'terraform_apply',
              client_payload: {
                source_owner: '${{ github.event.client_payload.source_owner }}',
                source_repo: '${{ github.event.client_payload.source_repo }}',
                pr_number: ${{ github.event.client_payload.pr_number }},
                pr_url: '${{ github.event.client_payload.pr_url }}',
                merge_commit_sha: '${{ steps.merge.outputs.merge_sha }}',
                action: 'apply',
                merged: 'true'
              }
            });
            
            console.log('âœ… Apply workflow triggered');

      # ===== TERRAFORM APPLY (when action == 'apply') =====
      - name: ğŸš€ Terraform Apply
        if: github.event.client_payload.action == 'apply' && (steps.discover.outputs.has_deployments == 'true' || steps.discover-apply.outputs.has_deployments == 'true')
        id: apply
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "ğŸš€ Running terraform apply for deployments..."
          echo "ğŸ”§ Terraform directory: $TERRAFORM_DIR"
          
          # Use the deployment orchestrator to run applies
          set +e  # Don't exit on error - we want to show results even if some applies fail
          python3 ../controller/scripts/terraform-deployment-orchestrator-enhanced.py apply \
            --changed-files "${{ github.event.client_payload.changed_files || github.event.client_payload.files }}" \
            --output-summary apply-results.json \
            --debug
          
          apply_exit_code=$?
          set -e
          
          echo "ğŸ” Apply exit code: $apply_exit_code"
          
          if [ -f apply-results.json ]; then
            total=$(jq -r '.summary.total // 0' apply-results.json)
            successful=$(jq -r '.summary.successful // 0' apply-results.json)
            failed=$(jq -r '.summary.failed // 0' apply-results.json)
            
            echo "ğŸ“Š Apply Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_applies=$successful" >> $GITHUB_OUTPUT
            echo "failed_applies=$failed" >> $GITHUB_OUTPUT
            
            if [ "$successful" -gt 0 ]; then
              echo "âœ… Applied $successful deployments successfully"
              if [ "$failed" -gt 0 ]; then
                echo "âš ï¸ $failed deployments failed"
                # Don't exit 1 here - let the PR comment show the results
              fi
            else
              echo "âŒ No successful applies"
              # Don't exit 1 here - let the PR comment show the results
            fi
          else
            echo "âŒ No apply-results.json found"
          fi

      - name: ğŸ’¬ Post Apply Results to PR
        if: github.event.client_payload.action == 'apply' && always() && (steps.discover.outputs.has_deployments == 'true' || steps.discover-apply.outputs.has_deployments == 'true')
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            
            let comment = `## ğŸš€ Terraform Apply Results\n\n`;
            comment += `**Merged PR**: [#${{ github.event.client_payload.pr_number }}](https://github.com/${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}/pull/${{ github.event.client_payload.pr_number }})\n`;
            comment += `**Applied to**: \`main\` branch\n\n`;
            
            const total = '${{ steps.apply.outputs.total_deployments }}';
            const successful = '${{ steps.apply.outputs.successful_applies }}';
            const failed = '${{ steps.apply.outputs.failed_applies }}';
            
            if (total && total !== '0') {
              comment += `### ğŸ“Š Apply Summary\n`;
              comment += `| Metric | Count |\n`;
              comment += `|--------|-------|\n`;
              comment += `| ğŸ“‹ Total Deployments | ${total} |\n`;
              comment += `| âœ… Successful Applies | ${successful} |\n`;
              comment += `| âŒ Failed Applies | ${failed} |\n\n`;
              
              // Add detailed results if available
              try {
                const applyResults = fs.readFileSync('source-repo/apply-results.json', 'utf8');
                const results = JSON.parse(applyResults);
                
                if (results.applies && results.applies.length > 0) {
                  comment += `### ğŸ“‹ Deployment Details\n`;
                  comment += `| Deployment | Status | Message |\n`;
                  comment += `|------------|--------|----------|\n`;
                  
                  results.applies.forEach(apply => {
                    const status = apply.status === 'success' ? 'âœ…' : 'âŒ';
                    const message = apply.message || 'N/A';
                    comment += `| ${apply.deployment} | ${status} | ${message.substring(0, 50)} |\n`;
                  });
                  comment += `\n`;
                }
              } catch (e) {
                console.log('Could not read apply results:', e.message);
              }
              
              if (failed === '0') {
                comment += `\nâœ… **All deployments applied successfully!**\n`;
              } else {
                comment += `\nâš ï¸ **Some deployments failed - check logs for details**\n`;
              }
            } else {
              comment += `â„¹ï¸ No deployments were applied\n`;
            }
            
            comment += `\n---\n`;
            comment += `ğŸ¤– *Centralized Controller - Apply* | `;
            comment += `[View Run](https://github.com/Terraform-centilazed-pipline/centerlized-pipline-/actions/runs/${{ github.run_id }})`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: ${{ github.event.client_payload.pr_number }},
              body: comment
            });

      # ===== CLEANUP: DELETE FEATURE BRANCH AFTER SUCCESSFUL APPLY =====
      - name: ğŸ§¹ Cleanup Feature Branch
        if: github.event.client_payload.action == 'apply' && steps.apply.outputs.successful_applies > 0
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = '${{ github.event.client_payload.source_owner }}';
            const repo = '${{ github.event.client_payload.source_repo }}';
            const pr_number = ${{ github.event.client_payload.pr_number }};
            
            try {
              // Get PR details to find the feature branch name
              const { data: prData } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr_number
              });
              
              const branchName = prData.head.ref;
              const branchSha = prData.head.sha;
              
              console.log(`ğŸ” Found feature branch: ${branchName} (${branchSha})`);
              
              // Don't delete protected branches (main, master, develop, etc.)
              const protectedBranches = ['main', 'master', 'develop', 'development', 'staging', 'production'];
              if (protectedBranches.includes(branchName)) {
                console.log(`âš ï¸ Skipping deletion of protected branch: ${branchName}`);
                return;
              }
              
              // Delete the feature branch
              await github.rest.git.deleteRef({
                owner,
                repo,
                ref: `heads/${branchName}`
              });
              
              console.log(`âœ… Successfully deleted feature branch: ${branchName}`);
              
              // Add notification comment about branch cleanup
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr_number,
                body: `ğŸ§¹ **Branch Cleanup Completed**\n\n` +
                      `âœ… Feature branch \`${branchName}\` has been automatically deleted after successful deployment.\n\n` +
                      `**Why?** To keep the repository clean and avoid accumulating stale branches.\n\n` +
                      `*If you need to make additional changes, please create a new feature branch.*`
              });
              
            } catch (error) {
              console.log('âš ï¸ Could not delete feature branch:', error.message);
              
              // Add comment about cleanup failure (non-blocking)
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr_number,
                  body: `âš ï¸ **Branch Cleanup Notice**\n\n` +
                        `Could not automatically delete the feature branch. This is not critical.\n\n` +
                        `**Reason**: ${error.message}\n\n` +
                        `*You may manually delete the branch if no longer needed.*`
                });
              } catch (commentError) {
                console.log('Could not post cleanup notice:', commentError.message);
              }
            }

      # ===== UPLOAD ARTIFACTS =====
      - name: ğŸ“¦ Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-controller-results
          path: |
            source-repo/deployments.json
            source-repo/plan-results.json
            source-repo/apply-results.json
            source-repo/terraform-json/
            source-repo/plan-markdown/
            source-repo/canonical-plan/
            source-repo/plans/
            source-repo/logs/
            source-repo/opa-result.txt
            source-repo/opa-results.json
            source-repo/*.log
