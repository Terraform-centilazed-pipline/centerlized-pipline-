# =============================================================================
# CENTRALIZED TERRAFORM CONTROLLER - OPTIMIZED
# =============================================================================
name: Centralized Controller

on:
  repository_dispatch:
    types: [terraform_pr, terraform_apply]

permissions:
  id-token: write
  contents: read
  actions: read

env:
  TERRAFORM_VERSION: '1.11.0'
  OPA_VERSION: '0.59.0'
  AWS_REGION: 'us-east-1'

jobs:
  terraform-controller:
    name: üéØ Terraform Controller
    runs-on: ubuntu-latest
    if: github.event.action == 'terraform_pr' || github.event.client_payload.action != 'apply'
    steps:
      - name: üìã Setup & Event Details
        id: setup
        run: |
          echo "üîî Source: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}"
          echo "üìã PR: #${{ github.event.client_payload.pr_number }} (${{ github.event.client_payload.pr_head_ref }})"

      - name: Generate GitHub App Token
        id: app-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GT_APP_ID }}
          private_key: ${{ secrets.GT_APP_PRIVATE_KEY }}

      - name: Checkout Repos
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/centerlized-pipline-
          path: controller
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout Source Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}
          ref: ${{ github.event.client_payload.pr_head_ref }}
          path: source-repo
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout OPA Policies
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/OPA-Poclies
          path: opa-policies
          token: ${{ steps.app-token.outputs.token }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-controller

      - name: üîß Setup Tools
        run: |
          # Setup Terraform
          curl -fsSL https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip -o terraform.zip
          unzip terraform.zip && sudo mv terraform /usr/local/bin/
          
          # Setup OPA (with fallback)
          curl -L -o opa https://openpolicyagent.org/downloads/v${{ env.OPA_VERSION }}/opa_linux_amd64_static || \
          curl -L -o opa https://github.com/open-policy-agent/opa/releases/download/v${{ env.OPA_VERSION }}/opa_linux_amd64_static
          chmod +x opa && sudo mv opa /usr/local/bin/
          
          # Setup yq
          sudo snap install yq
          
          # Pre-pull Docker image
          docker pull bridgecrew/checkov:latest

      - name: üîç Discover & Validate
        id: discover
        working-directory: source-repo
        run: |
          echo "üîç Discovering deployments..."
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --output-summary deployments.json --debug
          
          if [ -f deployments.json ]; then
            deployments=$(jq -r '.total_deployments // 0' deployments.json)
            echo "üì¶ Found $deployments deployments"
            echo "has_deployments=$([[ $deployments -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
            echo "deployment_count=$deployments" >> $GITHUB_OUTPUT
          else
            echo "has_deployments=false" >> $GITHUB_OUTPUT
            echo "deployment_count=0" >> $GITHUB_OUTPUT
          fi

      - name: üõ°Ô∏è Security Scan
        if: steps.discover.outputs.has_deployments == 'true'
        id: security
        working-directory: source-repo
        run: |
          echo "üõ°Ô∏è Running Checkov security scan..."
          
          # Get deployment files
          DEPLOYMENT_FILES=$(jq -r '.deployments[].tfvars_file' deployments.json | tr '\n' ' ')
          echo "üìÑ Scanning: $DEPLOYMENT_FILES"
          
          # Load security config
          CRITICAL_CHECKS=$(yq eval '.security_checks.critical[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
          HIGH_CHECKS=$(yq eval '.security_checks.high[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
          MEDIUM_CHECKS=$(yq eval '.security_checks.medium[]' ../controller/checkov-config.yaml | tr '\n' ',' | sed 's/,$//')
          ALL_CHECKS="${CRITICAL_CHECKS},${HIGH_CHECKS},${MEDIUM_CHECKS}"
          
          # Run Checkov
          mkdir -p checkov-results
          docker run --rm -v $PWD:/tf bridgecrew/checkov:latest \
            --framework terraform --check $ALL_CHECKS \
            --output json --output-file-path /tf/checkov-results/ \
            --quiet --soft-fail --compact $DEPLOYMENT_FILES || true
          
          # Process results
          if [ -f "checkov-results/results_json.json" ]; then
            critical=$(jq --arg checks "$CRITICAL_CHECKS" '[.results.failed_checks[]? | select(.check_id | IN($checks | split(",")))] | length' checkov-results/results_json.json 2>/dev/null || echo "0")
            high=$(jq --arg checks "$HIGH_CHECKS" '[.results.failed_checks[]? | select(.check_id | IN($checks | split(",")))] | length' checkov-results/results_json.json 2>/dev/null || echo "0")
            medium=$(jq --arg checks "$MEDIUM_CHECKS" '[.results.failed_checks[]? | select(.check_id | IN($checks | split(",")))] | length' checkov-results/results_json.json 2>/dev/null || echo "0")
            total=$((critical + high + medium))
            
            echo "üî¥ Critical: $critical, üü† High: $high, üü° Medium: $medium"
            echo "critical_issues=$critical" >> $GITHUB_OUTPUT
            echo "high_issues=$high" >> $GITHUB_OUTPUT
            echo "medium_issues=$medium" >> $GITHUB_OUTPUT
            echo "total_issues=$total" >> $GITHUB_OUTPUT
            
            # Determine status
            if [ "$critical" -gt 0 ]; then
              echo "scan_status=failed" >> $GITHUB_OUTPUT
              echo "scan_message=üî¥ Critical security issues found ($critical)" >> $GITHUB_OUTPUT
            elif [ "$high" -gt 2 ]; then
              echo "scan_status=failed" >> $GITHUB_OUTPUT
              echo "scan_message=‚ö†Ô∏è Too many high severity issues ($high)" >> $GITHUB_OUTPUT
            else
              echo "scan_status=passed" >> $GITHUB_OUTPUT
              echo "scan_message=‚úÖ Security scan passed" >> $GITHUB_OUTPUT
            fi
          else
            echo "scan_status=passed" >> $GITHUB_OUTPUT
            echo "scan_message=‚ÑπÔ∏è No security issues detected" >> $GITHUB_OUTPUT
          fi

      - name: üìã Terraform Plan
        if: steps.discover.outputs.has_deployments == 'true'
        id: plan
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "üìã Running terraform plan..."
          
          set +e
          python3 ../controller/scripts/terraform-deployment-orchestrator.py plan \
            --deployments-json deployments.json --output-summary plan-results.json --debug
          plan_exit_code=$?
          set -e
          
          if [ -f plan-results.json ]; then
            total=$(jq -r '.total_deployments // 0' plan-results.json)
            successful=$(jq -r '.successful_plans // 0' plan-results.json)
            failed=$(jq -r '.failed_plans // 0' plan-results.json)
            has_changes=$(jq -r '.has_changes // false' plan-results.json)
            
            echo "üìä Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_plans=$successful" >> $GITHUB_OUTPUT
            echo "failed_plans=$failed" >> $GITHUB_OUTPUT
            echo "has_changes=$has_changes" >> $GITHUB_OUTPUT
            
            # Prepare OPA validation
            if [ -d "terraform-json" ] && [ "$successful" -gt 0 ]; then
              mkdir -p canonical-plan
              FIRST_JSON=$(ls terraform-json/*.json 2>/dev/null | head -n1)
              if [ -n "$FIRST_JSON" ]; then
                cp "$FIRST_JSON" canonical-plan/plan.json
                echo "opa_plan_ready=true" >> $GITHUB_OUTPUT
              else
                echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "opa_plan_ready=false" >> $GITHUB_OUTPUT
            fi
            
            [[ "$successful" -gt 0 ]] || exit 1
          else
            echo "‚ùå No plan results found" && exit 1
          fi

      - name: üõ°Ô∏è Policy Validation (Project-based + Default)
        if: steps.plan.outputs.opa_plan_ready == 'true'
        id: opa
        working-directory: source-repo
        run: |
          echo "üõ°Ô∏è Running OPA validation with project-based policies..."
          
          # Check for project-specific policies first
          PROJECT_NAME="${{ github.event.client_payload.source_repo }}"
          echo "üîç Looking for project-specific policies for: $PROJECT_NAME"
          
          PROJECT_POLICY_DIR="../opa-policies/projects/$PROJECT_NAME"
          DEFAULT_POLICY_DIR="../opa-policies/terraform"
          
          # Determine which policies to use
          if [ -d "$PROJECT_POLICY_DIR" ] && [ -f "$PROJECT_POLICY_DIR/main.rego" ]; then
            echo "‚úÖ Found project-specific policies: $PROJECT_POLICY_DIR"
            POLICY_DIR="$PROJECT_POLICY_DIR"
            POLICY_TYPE="project-specific"
            echo "project_policy_found=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No project-specific policies found, using default policies"
            POLICY_DIR="$DEFAULT_POLICY_DIR"
            POLICY_TYPE="default"
            echo "project_policy_found=false" >> $GITHUB_OUTPUT
          fi
          
          echo "üìã Using policy type: $POLICY_TYPE"
          echo "policy_type=$POLICY_TYPE" >> $GITHUB_OUTPUT
          
          # Run validation with selected policies
          opa eval -d "$POLICY_DIR" -i canonical-plan/plan.json \
            "data.terraform.main.validate_plan" --format json > opa-validation.json
          
          # Extract results
          violations=$(jq -r '.result[0].expressions[0].value.total_violations // 0' opa-validation.json)
          critical=$(jq -r '.result[0].expressions[0].value.critical_violations // 0' opa-validation.json)
          high=$(jq -r '.result[0].expressions[0].value.high_violations // 0' opa-validation.json)
          
          echo "üîç Policy Results:"
          echo "   Policy Type: $POLICY_TYPE"
          echo "   Total Violations: $violations"
          echo "   Critical: $critical"
          echo "   High: $high"
          
          echo "total_violations=$violations" >> $GITHUB_OUTPUT
          echo "critical_violations=$critical" >> $GITHUB_OUTPUT
          echo "high_violations=$high" >> $GITHUB_OUTPUT
          
          # Save violation details for PR comment
          if [ "$violations" -gt 0 ]; then
            jq -r '.result[0].expressions[0].value.violation_details[]?' opa-validation.json > opa-result.txt 2>/dev/null || echo "No detailed violation info available" > opa-result.txt
          fi
          
          # Determine validation status and actions
          if [ "$violations" -eq 0 ]; then
            echo "validation_status=passed" >> $GITHUB_OUTPUT
            echo "requires_approval=false" >> $GITHUB_OUTPUT
            echo "auto_close=false" >> $GITHUB_OUTPUT
            echo "‚úÖ All policies passed!"
          elif [ "$POLICY_TYPE" = "project-specific" ]; then
            # Project-specific policies failed - require approval
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            echo "requires_approval=true" >> $GITHUB_OUTPUT
            echo "auto_close=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Project-specific policy violations found - manual approval required"
          else
            # Default policies failed - auto-close PR
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            echo "requires_approval=false" >> $GITHUB_OUTPUT
            echo "auto_close=true" >> $GITHUB_OUTPUT
            echo "‚ùå Default policy violations found - PR will be auto-closed"
          fi

      - name: üí¨ Enhanced PR Comments
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const prAuthor = '${{ github.event.client_payload.pr_author }}';
            const prNumber = '${{ github.event.client_payload.pr_number }}';
            
            let comment = `## üöÄ Centralized Terraform Controller Results\n\n`;
            comment += `**üë§ PR Author**: @${prAuthor}\n`;
            comment += `**Source**: \`${{ github.event.client_payload.source_repo }}\`\n`;
            comment += `**PR**: [#${prNumber}](${{ github.event.client_payload.pr_url }})\n\n`;
            
            // Security Results
            const scanStatus = '${{ steps.security.outputs.scan_status }}';
            const criticalIssues = '${{ steps.security.outputs.critical_issues }}' || '0';
            const highIssues = '${{ steps.security.outputs.high_issues }}' || '0';
            const totalIssues = '${{ steps.security.outputs.total_issues }}' || '0';
            
            comment += `### üõ°Ô∏è Security Scan\n`;
            comment += `**Status**: ${{ steps.security.outputs.scan_message }}\n`;
            if (totalIssues !== '0') {
              comment += `üî¥ Critical: ${criticalIssues} | üü† High: ${highIssues} | üìä Total: ${totalIssues}\n`;
              if (parseInt(criticalIssues) > 0) {
                comment += `> üö® **URGENT @${prAuthor}**: Critical security issues detected!\n`;
              }
            }
            comment += `\n`;
            
            // Plan Results
            const total = '${{ steps.plan.outputs.total_deployments }}' || '0';
            const successful = '${{ steps.plan.outputs.successful_plans }}' || '0';
            const failed = '${{ steps.plan.outputs.failed_plans }}' || '0';
            
            comment += `### üìã Terraform Plan\n`;
            comment += `‚úÖ Successful: ${successful}/${total} | ‚ùå Failed: ${failed}\n\n`;
            
            // Enhanced OPA Results
            const validation = '${{ steps.opa.outputs.validation_status }}';
            const violations = '${{ steps.opa.outputs.total_violations }}' || '0';
            const policyType = '${{ steps.opa.outputs.policy_type }}' || 'unknown';
            const projectPolicyFound = '${{ steps.opa.outputs.project_policy_found }}';
            const requiresApproval = '${{ steps.opa.outputs.requires_approval }}';
            const autoClose = '${{ steps.opa.outputs.auto_close }}';
            
            comment += `### üõ°Ô∏è Policy Validation (${policyType})\n`;
            if (validation === 'passed') {
              comment += `‚úÖ **All policies passed!**\n`;
            } else {
              comment += `‚ùå **${violations} violations** detected using **${policyType}** policies\n`;
              
              if (projectPolicyFound === 'false') {
                comment += `> üí° No project-specific policies found, using default validation rules\n`;
              }
              
              // Action Required Section
              if (requiresApproval === 'true') {
                comment += `\n### üîê Manual Approval Required\n`;
                comment += `**Project-specific policy violations detected.** This PR requires manual review.\n\n`;
                comment += `**Next Steps:**\n`;
                comment += `1. Review violations above\n`;
                comment += `2. Fix violations OR get security team approval\n`;
                comment += `3. Add comment \`@terrateam approve-policy\` to override\n\n`;
                comment += `> ‚ö†Ô∏è **Security Notice:** Project policies enforce your organization's specific requirements.\n`;
              } else if (autoClose === 'true') {
                comment += `\n### ‚ùå Auto-Closing PR\n`;
                comment += `**Default policy violations detected.** This PR will be automatically closed.\n\n`;
                comment += `**Why?** Default policies represent mandatory security requirements.\n`;
                comment += `**Fix Required:** Address all violations and reopen a new PR.\n`;
              }
            }
            comment += `\n`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: prNumber,
              body: comment
            });

      - name: ‚ùå Auto-Close PR for Default Policy Violations
        if: steps.opa.outputs.auto_close == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            console.log('ÔøΩ Auto-closing PR due to default policy violations');
            
            await github.rest.pulls.update({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              pull_number: ${{ github.event.client_payload.pr_number }},
              state: 'closed'
            });
            
            console.log('‚úÖ PR closed successfully');

      - name: üîê Add Approval Label for Project Policy Violations
        if: steps.opa.outputs.requires_approval == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            console.log('üè∑Ô∏è Adding approval required label');
            
            await github.rest.issues.addLabels({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: ${{ github.event.client_payload.pr_number }},
              labels: ['policy-approval-required', 'security-review']
            });
            
            console.log('‚úÖ Labels added successfully');

      - name: üîí Block Auto-Merge for Project Policy Violations
        if: steps.opa.outputs.requires_approval == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            console.log('üîí Blocking auto-merge until approval received');
            
            const approvalMessage = [
              '## üîê Manual Approval Required',
              '',
              'Project-specific policy violations detected. This PR is blocked until approved.',
              '',
              '**üë• Approval Commands:** (Engineering team only)',
              '- Comment `@terrateam approve-policy` to approve and allow merge',
              '- Comment `@terrateam deny-policy` to block this PR',
              '',
              '**‚úÖ Approved by:** Engineering team members: engineering-lead, devops-manager, security-architect',
              '',
              '**üîç Status:** ‚è≥ Waiting for approval...',
              '',
              '> üí° **Note:** Default policy violations auto-close PRs. Project policy violations require manual approval.'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: '${{ github.event.client_payload.pr_number }}',
              body: approvalMessage
            });

      - name: üö® Critical Alert
        if: steps.security.outputs.scan_status == 'failed' && steps.security.outputs.critical_issues > 0
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const prAuthor = '${{ github.event.client_payload.pr_author }}';
            const criticalCount = '${{ steps.security.outputs.critical_issues }}';
            const prNumber = '${{ github.event.client_payload.pr_number }}';
            
            const alertComment = `üö® **URGENT SECURITY ALERT** üö®\n\n` +
              `@${prAuthor} - **${criticalCount} Critical Security Issues** detected!\n\n` +
              `‚õî **Action Required**: Please fix these issues before proceeding.\n\n` +
              `üîí *Automated Security Alert*`;
            
            await github.rest.issues.createComment({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: prNumber,
              body: alertComment
            });

      - name: üîç Check Approval Status (for Project Policy Violations)
        if: steps.opa.outputs.requires_approval == 'true'
        id: approval_check
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // üîê CONFIGURE YOUR APPROVERS HERE
            // Replace these usernames with your actual GitHub usernames
            const approvers = [
              'pragadeeswarpa',         // Your GitHub username
              // Add your team members' actual GitHub usernames:
              // 'teammate1-github-username',
              // 'teammate2-github-username',
            ];
            
            console.log(`ÔøΩ Configured approvers: ${approvers.join(', ')}`);
            console.log('üîç Checking for approval comments...');
            
            const comments = await github.rest.issues.listComments({
              owner: '${{ github.event.client_payload.source_owner }}',
              repo: '${{ github.event.client_payload.source_repo }}',
              issue_number: '${{ github.event.client_payload.pr_number }}'
            });
            
            let approved = false;
            let approver = null;
            
            // Check latest comments first
            for (const comment of comments.data.reverse()) {
              const commenter = comment.user.login;
              const body = comment.body.trim();
              
              if (approvers.includes(commenter) && body.includes('@terrateam approve-policy')) {
                approved = true;
                approver = commenter;
                console.log(`‚úÖ Found approval from ${commenter}`);
                break;
              }
            }
            
            core.setOutput('approved', approved);
            core.setOutput('approver', approver);
            
            if (approved) {
              // Add approval confirmation comment
              const approvalMessage = [
                `‚úÖ **POLICY APPROVED** by @${approver}`,
                '',
                '**Status:** Ready for merge and deployment',
                '**Next Steps:** This PR will now auto-merge',
                '',
                'üöÄ Deployment will proceed automatically after merge'
              ].join('\n');
              
              await github.rest.issues.createComment({
                owner: '${{ github.event.client_payload.source_owner }}',
                repo: '${{ github.event.client_payload.source_repo }}',
                issue_number: '${{ github.event.client_payload.pr_number }}',
                body: approvalMessage
              });
            }

      - name: üîÄ Auto-merge
        if: |
          steps.opa.outputs.validation_status == 'passed' && 
          steps.security.outputs.scan_status == 'passed' && 
          (steps.opa.outputs.requires_approval != 'true' || steps.approval_check.outputs.approved == 'true')
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            try {
              await github.rest.pulls.merge({
                owner: '${{ github.event.client_payload.source_owner }}',
                repo: '${{ github.event.client_payload.source_repo }}',
                pull_number: ${{ github.event.client_payload.pr_number }},
                commit_title: 'Auto-merge: Security and policy validation passed',
                merge_method: 'squash'
              });
              console.log('‚úÖ PR auto-merged successfully');
            } catch (error) {
              console.log('‚ö†Ô∏è Auto-merge failed:', error.message);
            }

  # =============================================================================
  # TERRAFORM APPLY JOB (Runs after successful merge)
  # =============================================================================
  terraform-apply:
    name: üöÄ Terraform Apply
    runs-on: ubuntu-latest
    if: github.event.action == 'terraform_apply' || github.event.client_payload.action == 'apply'
    steps:
      - name: üìã Apply Event Details
        run: |
          echo "üöÄ Terraform Apply Triggered"
          echo "Source: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}"
          echo "Branch: ${{ github.event.client_payload.branch || 'main' }}"
          echo "Commit: ${{ github.event.client_payload.commit_sha }}"

      - name: Generate GitHub App Token
        id: app-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GT_APP_ID }}
          private_key: ${{ secrets.GT_APP_PRIVATE_KEY }}

      - name: Checkout Repos
        uses: actions/checkout@v4
        with:
          repository: Terraform-centilazed-pipline/centerlized-pipline-
          path: controller
          token: ${{ steps.app-token.outputs.token }}

      - name: Checkout Source Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_owner }}/${{ github.event.client_payload.source_repo }}
          ref: ${{ github.event.client_payload.branch || 'main' }}
          path: source-repo
          token: ${{ steps.app-token.outputs.token }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-apply

      - name: üîß Setup Terraform
        run: |
          curl -fsSL https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip -o terraform.zip
          unzip terraform.zip && sudo mv terraform /usr/local/bin/

      - name: üîç Discover Deployments
        id: discover
        working-directory: source-repo
        run: |
          echo "üîç Discovering deployments for apply..."
          python3 ../controller/scripts/terraform-deployment-orchestrator.py discover \
            --output-summary deployments.json --debug
          
          if [ -f deployments.json ]; then
            deployments=$(jq -r '.total_deployments // 0' deployments.json)
            echo "üì¶ Found $deployments deployments to apply"
            echo "has_deployments=$([[ $deployments -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          else
            echo "has_deployments=false" >> $GITHUB_OUTPUT
          fi

      - name: üöÄ Terraform Apply
        if: steps.discover.outputs.has_deployments == 'true'
        id: apply
        working-directory: source-repo
        env:
          TERRAFORM_DIR: ../controller
        run: |
          echo "üöÄ Running terraform apply..."
          
          set +e
          python3 ../controller/scripts/terraform-deployment-orchestrator.py apply \
            --deployments-json deployments.json --output-summary apply-results.json --debug
          apply_exit_code=$?
          set -e
          
          if [ -f apply-results.json ]; then
            total=$(jq -r '.total_deployments // 0' apply-results.json)
            successful=$(jq -r '.successful_applies // 0' apply-results.json)
            failed=$(jq -r '.failed_applies // 0' apply-results.json)
            
            echo "üìä Apply Results: $successful/$total successful, $failed failed"
            
            echo "total_deployments=$total" >> $GITHUB_OUTPUT
            echo "successful_applies=$successful" >> $GITHUB_OUTPUT
            echo "failed_applies=$failed" >> $GITHUB_OUTPUT
            
            if [ "$successful" -gt 0 ]; then
              echo "‚úÖ Apply completed with $successful successful deployments"
              exit 0
            else
              echo "‚ùå No deployments were successful"
              exit 1
            fi
          else
            echo "‚ùå No apply results found" && exit 1
          fi

      - name: üí¨ Post Apply Results
        if: always() && steps.discover.outputs.has_deployments == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const sourceRepo = '${{ github.event.client_payload.source_repo }}';
            const sourceOwner = '${{ github.event.client_payload.source_owner }}';
            const commitSha = '${{ github.event.client_payload.commit_sha }}';
            
            const total = '${{ steps.apply.outputs.total_deployments }}' || '0';
            const successful = '${{ steps.apply.outputs.successful_applies }}' || '0';
            const failed = '${{ steps.apply.outputs.failed_applies }}' || '0';
            
            let comment = `## üöÄ Terraform Apply Results\n\n`;
            comment += `**Repository**: \`${sourceRepo}\`\n`;
            comment += `**Commit**: \`${commitSha}\`\n\n`;
            comment += `### üìä Apply Summary\n`;
            comment += `‚úÖ Successful: ${successful}/${total}\n`;
            comment += `‚ùå Failed: ${failed}\n\n`;
            
            if (parseInt(successful) > 0) {
              comment += `üéâ **Infrastructure Successfully Deployed!**\n\n`;
            }
            
            if (parseInt(failed) > 0) {
              comment += `‚ö†Ô∏è **Some deployments failed** - please check the logs.\n\n`;
            }
            
            comment += `---\nü§ñ [View Run](https://github.com/Terraform-centilazed-pipline/centerlized-pipline-/actions/runs/${{ github.run_id }})`;
            
            // Create a commit comment instead of PR comment for apply results
            await github.rest.repos.createCommitComment({
              owner: sourceOwner,
              repo: sourceRepo,
              commit_sha: commitSha,
              body: comment
            });

      - name: üóëÔ∏è Delete Feature Branch After Successful Apply
        if: steps.apply.outputs.successful_applies > 0 && github.event.client_payload.source_ref != 'main' && github.event.client_payload.source_ref != 'master'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const sourceRepo = '${{ github.event.client_payload.source_repo }}';
            const sourceOwner = '${{ github.event.client_payload.source_owner }}';
            const branch = '${{ github.event.client_payload.source_ref }}';
            
            console.log(`üóëÔ∏è Attempting to delete branch: ${branch}`);
            
            try {
              await github.rest.git.deleteRef({
                owner: sourceOwner,
                repo: sourceRepo,
                ref: `heads/${branch}`
              });
              
              console.log(`‚úÖ Successfully deleted branch: ${branch}`);
              
              // Add a comment to the commit about branch deletion
              await github.rest.repos.createCommitComment({
                owner: sourceOwner,
                repo: sourceRepo,
                commit_sha: '${{ github.event.client_payload.commit_sha }}',
                body: `üóëÔ∏è **Branch Cleanup**: Feature branch \`${branch}\` has been automatically deleted after successful deployment.`
              });
              
            } catch (error) {
              console.log(`‚ö†Ô∏è Failed to delete branch ${branch}: ${error.message}`);
              // Don't fail the workflow if branch deletion fails
            }